=encoding utf8

=head1 Название

perl5220delta - что нового в perl v5.22.0

=head1 Описание

Этот документ описывает изменения между релизом 5.20.0 и 5.22.0.

Если вы обновляетесь с более раннего релиза, как например, 5.18.0, сначала
прочтите L<perl5200delta>, который описывает отличия между 5.18.0 и 5.20.0.

=head1 Базовые улучшения

=head2 Новые битовые операторы

Была добавлена новая экспериментальная возможность, которая позволяет четырём
стандартным битовым операторам (C<& | ^ ~>) всегда воспринимать свои операнды
как числа, а также представляет четыре новых оператора с точкой (C<&. |. ^. ~.>),
которые соответственно трактуют операнды как строки. Тоже самое
справедливо и для их вариаций с присвоением (C<&= |= ^= &.= |.= ^.=>).

Для активации этой возможности необходимо подключить возможность "bitwise" и
отключить категорию предупреждений "experimental::bitwise". Смотрите
подробности в L<perlop/Bitwise String Operators> и
L<[perl #123466]|https://rt.perl.org/Ticket/Display.html?id=123466>.

=head2 Новый оператор двойной ромб

C<<< <<>> >>> подобен C<< <> >>, но использует трёхаргументный вызов C<open>
для открытия файлов из C<@ARGV>. Это также означает, что каждый элемент
C<@ARGV> будет рассматриваться как имя файла, и, например, C<"|foo"> не будет
трактоваться как открытие канала.

=head2 Новые границы в C<\b> для регулярных выражений

=head3 C<qr/\b{gcb}/>

C<gcb> — сокращение от Grapheme Cluster Boundary (граница кластера
графемы). Это свойство Юникода, которое ищет границы между последовательностью
символов, которые являются представлением одного символа для носителя языка. В
Perl давно поддерживалась такая возможность с использованием последовательности
экранирования C<\X>. Теперь же появился альтернативный способ. Смотрите
подробности в L<perlrebackslash/\b{}, \b, \B{}, \B>

=head3 C<qr/\b{wb}/>

C<wb> — сокращение от Word Boundary (граница слова). Это свойство Юникода,
которое ищет границы между словами. Это полностью совпадает с обычным C<\b>
(без угловых скобок), но больше подходит при обработке текстов на естественных
языках. Свойство, к примеру, знает, что апостроф может находиться в середине
слова. Подробнее смотрите в L<perlrebackslash/\b{}, \b, \B{}, \B>.

=head3 C<qr/\b{sb}/>

C<sb> — сокращение от Sentence Boundary (граница предложения). Это свойство
Юникода, которое помогает при разборе предложений на естественных языках.
Смотрите подробности в L<perlrebackslash/\b{}, \b, \B{}, \B>.

=head2 Флаг регулярных выражений для отключения захвата

Регулярные выражения теперь поддерживают флаг C</n>, который отключает захват и
заполнение переменных C<$1>, C<$2>, и прочих внутри группировки:

  "hello" =~ /(hi|hello)/n; # $1 не устанавливается

Это эквивалентно установке C<?:> в начале каждой захватывающей группы.

Смотрите подробности в L<perlre/"n">.

=head2 C<use re 'strict'>

Это выражение включает строгие синтаксические правила к шаблонам регулярных
выражений, скомпилированным в области видимости данной прагмы. Это позволит
предупредить вас об опечатках и других нежелательных последствиях, о которых
нет возможности сообщить при обычной компиляции регулярных выражений из-за
соображений обратной совместимости. Поскольку поведение подобной прагмы может
измениться в будущих версиях Perl, по мере накопления опыта её применения, её
использование приводит к выводу предупреждения категории
C<experimental::re_strict>. Смотрите подробнее в
L<'strict' в re|re/'strict' mode>.

=head2 Поддерживается Юникод 7.0 (с корректировками)

Подробнее детали о том, что есть в этом релизе смотрите в
L<http://www.unicode.org/versions/Unicode7.0.0/>.  Версия Юникод 7.0,
поставляемая с Perl, включает корректировки, имеющие отношения к формированию
Арабских глифов (смотрите L<http://www.unicode.org/errata/#current_errata>).

=head2 S<C<use locale>> может ограничивать затронутые категории локалей

Теперь появилась возможность передавать параметр в S<C<use locale>> для
указания списка категорий локали, для которых будут применяться правила локали,
оставляя остальные категории незатронутыми. Подробности смотрите в
L<perllocale/The "use locale" pragma>.

=head2 Perl теперь поддерживает дополнения локальной валюты POSIX 2008

На платформах, которые поддерживают стандарт POSIX.1-2008, хеш, возвращаемый
L<C<POSIX::localeconv()>|perllocale/The localeconv function>, включает
дополнительные поля национальной валюты, определённые этой версией POSIX
стандарта. Это следующие поля:

C<int_n_cs_precedes>,
C<int_n_sep_by_space>,
C<int_n_sign_posn>,
C<int_p_cs_precedes>,
C<int_p_sep_by_space>,
и
C<int_p_sign_posn>.

=head2 Лучшая эвристика на старых платформах для определения является ли локаль UTF-8

На платформах, которые не реализовали ни стандарт C99, ни стандарт POSIX 2001,
определение, является ли локаль UTF-8 или нет, зависит от эвристики. Которая
была улучшена в этом релизе.

=head2 Псевдонимы через ссылки

Переменным и подпрограммам теперь можно задавать псевдонимы, присваивая к
ссылке:

    \$c = \$d;
    \&x = \&y;

Псевдонимы также могут быть назначены с использованием обратного слеша перед
переменной итерации C<foreach>; это, вероятно, одна из наиболее полезных идиом,
которые предоставляет данная возможность:

    foreach \%hash (@array_of_hash_refs) { ... }

Эта возможность экспериментальная и должна включаться с помощью
S<C<use feature 'refaliasing'>>. Она выводит предупреждение, если не отключена
категория предупреждений C<experimental::refaliasing>.

Смотрите L<perlref/Assigning to References>.

=head2 C<prototype> без аргументов

C<prototype()> без аргументов теперь подразумевает использование значения
C<$_>. L<[perl #123514]|https://rt.perl.org/Ticket/Display.html?id=123514>.

=head2 Новый атрибут функции C<:const>

Атрибут C<const> может быть применён к анонимным функциям. Это приводит к тому,
что функция немедленно исполняется всякий раз, когда создаётся (то есть когда
обрабатывается выражение C<sub>). Её значение запоминается и используется для
создания новой функции-константы, которая и возвращается. Это возможность
экспериментальная. Смотрите L<perlsub/Constant Functions>.

=head2 C<fileno> теперь работает и с дескрипторами директории

Если подобная возможность поддерживается в операционной системе, то встроенный
C<fileno> поддерживает работу с дескрипторами директорий, обрабатывая указанный
файловый дескриптор, как файловый хендлер. На операционных системах без
подобной поддержки C<fileno> на дескрипторе директории продолжит возвращать
неопределённое значение, как раньше, но также будет устанавливать C<$!> для
указания того, что операция не поддерживается.

На данный момент используется поле C<dd_fd> в структуре ОС C<DIR> или
функция C<dirfd(3)>, как определено в стандарте POSIX.1-2008.

=head2 Списочная форма записи для открытия канала реализована на Win32

Списочная форма записи для открытия канала:

  open my $fh, "-|", "program", @arguments;

теперь реализована на Win32. Она имела те же ограничения, как и C<system LIST>
на Win32, т.к. Win32 API не поддерживает передачу аргументов программе в виде
списка.

=head2 Присвоение списку с повторением

C<(...) x ...> может быть теперь использован внутри списка, которому
производится присвоение, пока левая сторона является lvalue. Это позволяет
записывать S<C<(undef,undef,$foo) = that_function()>> как
S<C<((undef)x2, $foo) = that_function()>>.

=head2 Улучшена обработка Infinity (бесконечность) и NaN (не-число)

Значения с плавающей запятой способны хранить специальные значения
бесконечности, отрицательной бесконечности и NaN (не-число). Теперь мы быстрее
распознаём и передаём результаты вычисления, а на выводе нормализуем их в
строковые значения C<Inf>, C<-Inf>, and C<NaN>.

Смотрите также улучшения в L<POSIX>.

=head2 Улучшен разбор значений с плавающей запятой

Был улучшен разбор и вывод значений с плавающей запятой.

Как совершенно новая возможность, теперь поддерживается запись в виде
шестнадцатеричных литералов (например, C<0x1.23p-4>) и они могут быть выведены с
помощью S<C<printf "%a">>. Смотрите подробности в
L<perldata/Scalar value constructors>.

=head2 Упаковка бесконечности или не-числа в символ теперь фатальная ошибка

Раньше, при попытке упаковки бесконечности или не-числа в (знаковый) символ,
Perl предупреждал об этом и подразумевал, что вы пытаетесь упаковать
C<< 0xFF >>; если вы передавали это как аргумент к C<< chr >>, то возвращался
C<< U+FFFD >>.

Но сейчас все подобные действия (C<< pack >>, C<< chr >> и C<< print '%c' >>)
приведут к фатальной ошибке.

=head2 Экспериментальное C API трассировки вызовов

Perl теперь поддерживает (через API C-уровня) получение трассировки вызовов уровня C
(также как работают символьные отладчики, например, gdb).

Бэктрейс содержит трассировку стека фреймов C-вызовов с именами символов
(именами функций), именами объектов (как, например, "perl"), а также, если
возможно, расположение в исходном коде (файл:строка).

Поддерживаются платформы Linux и OS X (на некоторых *BSD также может работать,
по крайне мере частично, но они ещё не тестировались).

Данная возможность должна быть включена с помощью C<Configure -Dusecbacktrace>.

Смотрите подробнее в L<perlhacktips/"C backtrace">.

=head1 Безопасность

=head2 Perl теперь компилируется с опцией C<-fstack-protector-strong>, если она доступна

Perl компилировался с опцией, предотвращающей переполнение буфера стека 
C<-fstack-protector>, начиная с 5.10.1. Теперь Perl использует более новый
вариант C<-fstack-protector-strong>, если он доступен.

=head2 Модуль L<Safe> допускал замещение внешних пакетов

Критическое исправление: внешние пакеты могли быть замещены. L<Safe> был
исправлен в версии 2.38.

=head2 Perl теперь всегда компилируется с опцией C<-D_FORTIFY_SOURCE=2>, если она доступна

Опция 'закалки кода', называемая C<_FORTIFY_SOURCE>, доступная в gcc 4.*,
теперь всегда используется для компиляции Perl, если доступна.

Следует отметить, что это не обязательно значительное изменение, так как на
многих платформах эта опция уже используется несколько лет: большинство Linux
дистрибутивов (например, Fedora) используют эту опцию для Perl, а также в OS X
она устанавливается уже много лет.

=head1 Несовместимые изменения

=head2 Сигнатура функции перемещена перед атрибутами

Экспериментальная возможность сигнатуры функции, появившаяся в 5.20,
обрабатывала сигнатуру после атрибутов. В данном релизе, следуя отзывам
пользователей этой экспериментальной возможности, позиция была перемещена так,
чтобы сигнатура располагалась после имени подпрограммы (если есть) и перед
списком атрибутов (если есть).

=head2 Прототипы C<&> и C<\&> допускают только функции

Символ прототипа C<&> теперь принимает только анонимные функции (C<sub
{...}>), начинающиеся с C<\&>, или явный C<undef>. Прежде они ошибочно
допускали использование ссылок на массивы, хеши и списки.
L<[perl #4539]|https://rt.perl.org/Ticket/Display.html?id=4539>.
L<[perl #123062]|https://rt.perl.org/Ticket/Display.html?id=123062>.
L<[perl #123062]|https://rt.perl.org/Ticket/Display.html?id=123475>.

Дополнительно, прототип C<\&> допускал вызов функции, тогда как сейчас он
допускает только функции: C<&foo> по-прежнему допустимый аргумент, в то время
как C<&foo()> и C<foo()> больше нет.
L<[perl #77860]|https://rt.perl.org/Ticket/Display.html?id=77860>.

=head2 C<use encoding> теперь лексическая

Прагма L<encoding> теперь ограничена лексической областью видимости. Эта прагма
устарела, но между тем, она может вредно воздействовать на другие модули,
которые подключены в той же программе. Теперь это исправлено.

=head2 Срезы списков, возвращающие пустые списки

Срезы списков теперь возвращают пустой список, только если оригинальный список
был пустым (или если нет индексов). Прежде срез списка возвращал пустой список
если все индексы оказывались вне оригинального списка; теперь в этом случае
возвращается список со значениями C<undef>.
L<[perl #114498]|https://rt.perl.org/Ticket/Display.html?id=114498>.

=head2 C<\N{}> с последовательностью пробелов теперь является фатальной ошибкой

Например, S<C<\N{ОЧЕНЬE<nbsp>E<nbsp>МНОГО ПРОБЕЛОВ}>> или S<C<\N{ЗАВЕРШАЮЩИЙ ПРОБЕЛ }>>.
Это являлось устаревшей конструкцией, начиная с v5.18.

=head2 S<C<use UNIVERSAL '...'>> теперь фатальная ошибка

Импортирование функций из C<UNIVERSAL> является устаревшей операцией, начиная с
v5.12 и теперь это фатальная ошибка. S<C<use UNIVERSAL>> без аргументов
по-прежнему допускается.

=head2 В выражении C<\cI<X>>, I<X> должен быть печатным ASCII символом

В предыдущих релизах, невыполнение этого условия приводило к сообщению об
устаревшей конструкции.

=head2 Разделение лексем C<(?> и C<(*> в регулярных выражениях теперь фатальная ошибка при компиляции.

Это является устаревшей конструкцией, начиная с v5.18.

=head2 C<qr/foo/x> теперь игнорирует все Юникод-шаблоны пробельного символа

Модификатор регулярного выражения C</x> разрешал использование в шаблонах
пробельных символов и комментариев (которые игнорировались) для удобства
чтения. До текущего момента не все пробельные символы, которые стандарт Юникод
обозначил для этих целей, поддерживались. Теперь также поддерживаются символы:

    U+0085 NEXT LINE
    U+200E LEFT-TO-RIGHT MARK
    U+200F RIGHT-TO-LEFT MARK
    U+2028 LINE SEPARATOR
    U+2029 PARAGRAPH SEPARATOR

Использование этих символов вместе с C</x> вне классов символов, обособляемых
скобками, и не предваряемых обратным слешем раньше, начиная с v5.18, выводило
предупреждение об устаревшей конструкции. Теперь же они игнорируются.

=head2 Строки комментариев внутри S<C<(?[ ])>> теперь могут завершаться только символом C<\n>

S<C<(?[ ])>> — это экспериментальная возможность, появившаяся в v5.18. Она
действует, как если бы был активирован модификатор C</x>. Но есть отличие:
строки комментариев (начинающиеся с символа C<#>) экранируются любым символом,
который совпадает с C<\R>, что включает в себя все вертикальные пробелы, такие
как разрыв страницы. Теперь, для согласованности, это поведение было изменено и
для завершения строк комментариев вне S<C<(?[ ])>> используется C<\n> (даже
если экранирован), что является тем же символом, который завершает строку
встроенного документа и формата.

=head2 Операторы C<(?[...])> теперь следуют стандарту приоритетов в Perl

Это экспериментальная возможность, которая разрешает операции с наборами в
регулярных выражениях. До этого оператор пересечения имел тот же приоритет, что
и другие бинарные операции. Теперь он имеет более высокий приоритет. Это может
привести к отличному поведению, чем ожидает существующий код (хотя документация
всегда отмечала, что это изменение может произойти и рекомендовала полностью
брать выражение в скобки). Смотрите в L<perlrecharclass/Extended Bracketed
Character Classes>.

=head2 Опускание C<%> и C<@> перед именами хешей и массивов больше не допускается

Очень старые версии Perl допускали пропуск C<@> для имён массивов и C<%> у
имён хешей в некоторых местах. Это приводило к предупреждению об устаревшей
конструкции, начиная с Perl 5.000, и теперь больше не разрешено.

=head2 Текст C<"$!"> теперь на английском языке вне области действия C<use locale>

Раньше текст, в отличии от всего другого, всегда базировался на текущей локали
программы (также действовало на некоторых системах на C<"$^E">). Для программ,
которые неготовы обрабатывать отличия в локалях, это может приводить к
отображению мусорного текста. Гораздо лучше отображать текст, который может
быть переведён через определённые утилиты, чем мусор, который труднее
распознать.

=head2 Текст C<"$!"> будет возвращён в UTF-8, если это приемлимо

Приведение к строковому значению C<$!> и C<$^E> установит флаг UTF-8, если
текст является не-ASCII UTF-8. Это позволит программам, которые настроены на
локале-зависимую работу, корректно выводит сообщения на естественном языке
пользователя. Код, которому требуется оставить поведение 5.20 и более ранних
версий, может приводить к строке в области действия прагм S<C<use bytes>> и
S<C<use locale ":messages">>. Внутри подобных областей никакие Perl операции не
будут затронуты локалью, кроме приведения к строке значений C<$!> как C<$^E>.
Прагма C<bytes> предотвратит установку флага UTF-8, также, как и в предыдущих
Perl релизах. Это исправляет баг
L<[perl #112208]|https://rt.perl.org/Ticket/Display.html?id=112208>.

=head2 Удалена поддержка записи C<?ШАБЛОН?> без явного оператора

Конструкция C<m?ШАБЛОН?>, которая допускает только одно совпадение в регулярном
выражении, раньше имела альтернативную форму записи, которая позволяла опускать
явный оператор C<m>. Подобное использование выдавало предупреждение об
устаревшей конструкции, начиная с 5.14.0. Теперь это синтаксическая ошибка,
освобождая символ вопроса для использования в новых операторах в будущем.

=head2 C<defined(@array)> и C<defined(%hash)> теперь фатальные ошибки

Эти конструкции устарели, начиная с v5.6.1, и выводили предупреждение об
устаревшей конструкции, начиная с v5.16.

=head2 Использование хеша или массива как ссылки теперь фатальная ошибка

Например, C<< %foo->{"bar"} >> теперь приводит к фатальной ошибке при
компиляции. Это устарело, начиная с v5.8 и с тех пор выводило предупреждение об
устаревшей конструкции.

=head2 Изменения в прототипе C<*>

Символ C<*> в прототипе подпрограммы раньше давал приоритет для bareword над
большинством имён подпрограмм (но не над всеми). Это никогда не было
последовательным и приводило к ошибочному поведению.

Теперь это было изменено и подпрограммы всегда получают приоритет над bareword,
что приводит к согласованному поведению со встроенными функциями с аналогичными
прототипами:

    sub splat(*) { ... }
    sub foo { ... }
    splat(foo); # теперь всегда splat(foo())
    splat(bar); # по-прежнему splat('bar'), как и раньше
    close(foo); # close(foo())
    close(bar); # close('bar')

=head1 Устаревшие конструкции

=head2 Установка C<${^ENCODING}> в что-либо отличное от C<undef>

Эта переменная позволяет писать Perl скрипты в кодировку отличную от ASCII или
UTF-8. Однако она затрагивает все модули глобально, приводя к некорректным
результатам и ошибкам сегментации. Новые скрипты должны писаться в UTF-8;
старые должны быть сконвертированы в UTF-8, что может быть легко сделано с
помощью утилиты L<piconv>.

=head2 Использование неграфических символов в односимвольном имени переменной

Синтаксис для одно-буквенного имени переменной более снисходителен, чем для
более длинных имён переменных, позволяя использовать одно-символьные имена с
символами пунктуации или даже невидимыми (неграфическими). Perl v5.20 объявил
устаревшим использование контрольных символов ASCII для подобных имён. Теперь
все неграфические символы, которые формально были разрешены теперь считаются
устаревшими. Практический эффект от этого происходит, только когда не действует
C<S<use utf8>>, и затрагивает только контрольные символы C1 (кодовые точки от
0x80 до 0xFF), NO-BREAK SPACE и SOFT HYPHEN.

=head2 Встраивание C<sub () { $var }> с заметным побочным эффектом

Во многих случаях Perl превращает S<C<sub () { $var }>> во встраиваемую
функцию-константу, захватывая значение C<$var> во время интерпретации выражения
C<sub>. Это может нарушить замыкание в тех случаях, когда C<$var> в последствии
модифицируется, поскольку подпрограмма не вернёт изменённое значение (это
применимо только к анонимным подпрограммам с пустым прототипом (S<C<sub ()>>)).

Подобное использование теперь считается устаревшим в тех случаях, когда
переменная модифицируется. Perl фиксирует подобные случаи и выводит
предупреждение об устаревшей конструкции. Подобный код в будущем скорее всего
изменит своё поведение и перестанет возвращать константу.

Если ваша переменная изменяется только в месте, где она определена, то Perl
продолжит создавать встраиваемую подпрограмму без каких-либо предупреждений.

    sub make_constant {
        my $var = shift;
        return sub () { $var }; # приемлимо
    }

    sub make_constant_deprecated {
        my $var;
        $var = shift;
        return sub () { $var }; # устаревшая конструкция
    }

    sub make_constant_deprecated2 {
        my $var = shift;
        log_that_value($var);   # может изменить $var
        return sub () { $var }; # устаревшая конструкция
    }

Выше, во втором примере, достаточно сложно вычислить, что присвоение C<$var>
делается только один раз. Это происходит в месте отличном от декларации C<my>,
что достаточно для Perl, чтобы считать это подозрительным.

Это предупреждение об устаревшей конструкции происходит только для простых
переменных в теле подпрограммы (блок C<BEGIN> или оператор C<use> внутри
подпрограмм игнорируются, поскольку они не становятся частью тела
подпрограммы). Для более сложных случаев, таких как S<C<sub () { do_something()
if 0; $var }>>, поведение изменилось и встраивания не происходит, если
переменная изменяется где-либо ещё. Подобные случаи встречаются редко.

=head2 Использование нескольких подификаторов регулярных выражений C</x>

Теперь считается устаревшим использование подобных записей:

    qr/foo/xx;
    /(?xax:foo)/;
    use re qw(/amxx);

Теперь C<x> должен встречаться только один раз в строке, содержащей
модификаторы регулярного выражения. Мы не склонны считать, что подобные
случаи встречаются на CPAN. Это подготовка к будущему релизу Perl, который
будет иметь C</xx> для разрешения пробелов для удобства чтения в классах
символов заключённых в скобки (которые обособляются квадратными скобками:
C<[...]>).

=head2 Использование неразрывного пробела в псевдонимах символа C<\N{...}> считается устаревшим

Этот неграфический символ практически неотличим от обычного пробела и поэтому
не должен допускаться. Смотрите L<charnames/CUSTOM ALIASES>.

=head2 Литерал C<"{"> теперь должен экранироваться в шаблоне

Если вам требуется литерал левой фигурной скобки в шаблоне регулярного
выражения, вы должны экранировать его с помощью предшествующего обратного
слеша, или включив его в квадратные скобки, или используя C<\Q>; в противном
случае будет выведено предупреждение об устаревшей конструкции. Впервые об этом
было анонсировано в релизе v5.16; это позволит в будущем расширить синтаксис
языка.

=head2 Не рекомендуется установливать все предупреждения фатальными

Документация для L<фатальных предупреждений|warnings/Fatal Warnings> отмечает,
что использование C<< use warnings FATAL => 'all' >> не рекомендуется и даёт
общие пояснения по рискам использования фатальных предупреждений.

=head1 Улучшения в производительности

=over 4

=item *

Если метод или имя класса известны во время компиляции, то предварительно
рассчитывается хеш для ускорения поиска методов во время исполнения. Также
составные имена методов, такие как C<SUPER::new>, разбираются во время
компиляции, что снимает необходимость их обработки во время исполнения.

=item *

Поиск элемента в массивах и хешах (особенно во вложенных), при котором
используется константа или простая переменная в качестве индекса/ключа, теперь
работает гораздо быстрее. Смотрите подробнее в L</Internal Changes>.

=item *

C<(...)x1>, C<("constant")x0> и C<($scalar)x0> теперь оптимизированы в
списочном контексте. Если правый аргумент константа 1, оператор повтора
исчезает. Если правый аргумент это константа 0, то всё выражение оптимизируется
в пустой список, если левый аргумент это простой скаляр или константа (таким
образом, C<(foo())x0> не оптимизируется).

=item *

Присвоение C<substr> в конце подпрограммы (или как аргумент C<return>) теперь
оптимизируется в 4-х аргументный C<substr>. Раньше это происходило только в
пустом контексте.

=item *

В C<"\L...">, C<"\Q..."> и подобных случаях дополнительная операция приведения
к строке теперь оптимизируется, делая их такими же быстрыми, как C<lcfirst>,
C<quotemeta>, и так далее.

=item *

Присвоение пустому списку теперь иногда работает быстрее. В частности, теперь
никогда не вызывается C<FETCH> на связанные аргументы на правой стороне, в то
время как раньше это иногда происходило.

=item *

Производительность C<length> увеличена на 20% если применяется к немагической,
несвязанной строке, или, если находится в области видимости прагмы C<use
bytes>, или если строка не использует внутри UTF-8.

=item *

На большинстве сборок perl с 64-битными целыми использование памяти для
немагических, несвязанных скалярах, содержащих только значение с плавающей
точкой было уменьшено от 8 до 32 байт в зависимости от ОС.

=item *

В выражении C<@array = split> присвоение может быть оптимизировано так, что
C<split> будет записывать непосредственно в массив. Эта оптимизация раньше
происходила только для массивов пакета, отличных от C<@_> и только иногда.
Теперь эта оптимизация происходит практически всегда.

=item *

C<join> теперь может выполнять свёртку констант. Например, S<C<join "-", "a",
"b">> конвертируется во время компиляции в C<"a-b">. Более того, C<join> со
скаляром или константой в качестве разделителя с одно-элементным списком
упрощается до операции приведения к строке, а разделитель даже не
обрабатывается.

=item *

C<qq(@array)> реализован с использованием двух операций: операция приведения к
строке и операция объединения. Если C<qq> не содержит ничего кроме одного
массива, то операция приведения к строке опускается.

=item *

S<C<our $var>> и S<C<our($s,@a,%h)>> в пустом контексте больше не вычисляются
во время выполнения. Даже вся последовательность выражений S<C<our $foo;>>
будет просто пропущена. Тоже самое относится к переменным C<state>.

=item *

Множество внутренних функция было переработано, чтобы улучшить
производительность и снизить их потребление памяти.
L<[perl #121436]|https://rt.perl.org/Ticket/Display.html?id=121436>
L<[perl #121906]|https://rt.perl.org/Ticket/Display.html?id=121906>
L<[perl #121969]|https://rt.perl.org/Ticket/Display.html?id=121969>

=item *

Файловые тесты C<-T> и C<-B> завершаться раньше, если будет выявлено, что файл
пустой.
L<[perl #121489]|https://rt.perl.org/Ticket/Display.html?id=121489>

=item *

Поиск в хеше по ключу-константе происходит быстрее.

=item *

Подпрограммы с пустыми прототипами и телом, содержащим только C<undef> теперь
могут встраиваться.
L<[perl #122728]|https://rt.perl.org/Ticket/Display.html?id=122728>

=item *

Подпрограммы в пакетах больше не требуется сохранять в тайпглобах: объявление
подпрограммы теперь помещает простую ссылку на подпрограмму непосредственно в
стэш, если это возможно, экономя память. Тайпглоб по-прежнему номинально
существует, попытка доступа к нему приведёт к модернизации стэша в тайпглоб
(это просто детали внутренней реализации). Эта оптимизация на данный момент не
применяется для XSUB или экспортированных подпрограмм, и вызов методов устранит
её, поскольку они сохраняют кэш в тайпглобах.
L<[perl #120441]|https://rt.perl.org/Ticket/Display.html?id=120441>

=item *

Функции C<utf8::native_to_unicode()> и C<utf8::unicode_to_native()> (смотрите
L<utf8>) теперь оптимизируются на ASCII платформах. Теперь нет ни малейшего
снижения производительности при написании кода, переносимого между ASCII и
EBCDIC платформ.

=item *

Win32 Perl использует меньше на 8 Кбайт памяти на каждый процесс, чем раньше,
поскольку некоторые данные теперь отображаются в память с диска и разделяются
между процессами одного исполняемого файла perl.

=back

=head1 Модули и прагмы

=head2 Обновлённые модули и прагмы

Многие библиотеки, распространяемые вместе с perl были обновлены, со времени
выхода v5.20.0. Для получения полного списка изменений можно выполнить:

  corelist --diff 5.20.0 5.22.0

Вы также можете подставить нужную вам версию вместо 5.20.0.

Некоторые заметные изменения:

=over 4

=item *

L<Archive::Tar> был обновлён до версии 2.04.

Тесты теперь могут выполняться параллельно.

=item *

L<attributes> был обновлён до версии 0.27.

Использование C<memEQs> в XS было исправлено.
L<[perl #122701]|https://rt.perl.org/Ticket/Display.html?id=122701>

Предотвращено чтение за пределами границы буфера. [perl #122629]

=item *

L<B> был обновлён до версии 1.58.

Он предоставляет новую функцию C<B::safename>, основанную на существующей
C<< B::GV->SAFENAME >>, которая конвертирует C<\cOPEN> в C<^OPEN>.

Обнулённые COP'ы теперь имеют класс C<B::COP>, вместо C<B::OP>.

Объекты C<B::REGEXP> теперь предоставляют метод C<qr_anoncv> для доступа к
неявным CV, ассоциированным с C<qr//>, содержащими кодовые блоки, а метод
C<compflags>, который возвращает соответствующие флаги, относящиеся к операции
C<qr//blahblah>.

C<B::PMOP> теперь предоставляет метод C<pmregexp>, возвращающий объект
C<B::REGEXP>. Были созданы два новых класса: C<B::PADNAME> и C<B::PADNAMELIST>.

Была исправлена ошибка, когда после создания треда или псевдофорка, специальные
или бессмертные SV в потомке треда/псевдофорка не имеют корректного класса
C<B::SPECIAL>.
Были добавлены методы PADLIST C<id> и C<outid>.

=item *

L<B::Concise> был обновлён до версии 0.996.

Нулевые операции, которые являются частью цепи исполнения теперь получают
соответствующие порядковые номера.

Закрытые флаги для нулевых операций теперь выводятся с мнемоникой, как и у
ненулевых операций.

=item *

L<B::Deparse> был обновлён до версии 1.35.

Теперь он корректно депарсит C<+sub : attr { ... }> с начала выражения. Без
начального C<+>, C<sub> стал бы меткой оператора.

Блоки C<BEGIN> теперь появляются в нужных местах в большинстве случаев, но это
изменение, к сожалению, приводит к регрессии, при которой блоки C<BEGIN>,
находящиеся прямо перед концом блока могут оказаться после него.

C<B::Deparse> больше не помещает некорректные C<local> тут и там, как например,
в C<LIST = tr/a//d>.  [perl #119815]

Соседние операторы C<use> больше не вкладываются, если один из них содержит
блок C<do>.  [perl #115066]

Массивы в скобках в списке, передаваемом с C<\> теперь корректно депарсятся со
скобками (то есть, C<\(@a, (@b), @c)> теперь сохранит скобки вокруг @b),
предотвращая от выравнивания массивов в списке по ссылке. Раньше это работало
только для одного массива: C<\(@a)>.

C<local our> теперь корректно депарсится, с включённым C<our>.

C<for($foo; !$bar; $baz) {...}> депарсился без C<!> (или C<not>).
Это было исправлено.

Базовые ключевые слова, которые конфликтуют с лексическим подпрограммами теперь
депарсятся с префиксом C<CORE::>.

C<foreach state $x (...) {...}> теперь корректно депарсится со C<state>, а не с
C<my>.

C<our @array = split(...)> теперь депарсится корректно с C<our> в тех случаях,
когда выражение оптимизируется.


Теперь депарсятся корректно C<our(I<LIST>)> и типизированное лексическое
(C<my Dog $spot>).

C<$#_> теперь депарсится корректно, вместо C<$#{_}>.
L<[perl #123947]|https://rt.perl.org/Ticket/Display.html?id=123947>

Блоки BEGIN в конце замыкающей области видимости теперь депарсятся в нужном
месте.  [perl #77452]

Блоки BEGIN иногда депарсились, как __ANON__, но теперь всегда называются
BEGIN.

Лексические подпрограммы теперь полностью депарсятся.  [perl #116553]

C<Anything =~ y///r> с C</r> больше не пропускают левый операндю

Дерево операций, которые формируют кодовый блок regexp теперь депарсятся
по-настоящему. Раньше использовалась оригинальная строка, которая создавала
регулярное выражение. Это приводило к проблемам с C<qr/(?{E<lt>E<lt>heredoc})/>
и многострочным блокам кода, которые депарсились некорректно. [perl #123217]
[perl #115256]

C<$;> в конце оператора больше не теряет точку с запятой. [perl #123357]

Некоторые случаи объявления подпрограмм, сохраняемые в стеше в краткой форме
пропускались.

Не-ASCII символы теперь последовательно экранируются в строках, без пропусков.
(По-прежнему есть проблемы с регулярными выражениями и идентификаторами,
которые ещё не исправлены.)

Когда прототип вызова подпрограммы депарсится с C<&> (например, с опцией
B<-P>), теперь добавляется C<scalar>, когда это требуется, чтобы принудительно
установить скалярный контекст, подразумеваемый прототипом.

C<require(foo())>, C<do(foo())>, C<goto(foo())> и схожие конструкции с
контролем циклов теперь корректно депарсятся. Внешние скобки не опциональные.

Пробельные символы больше не экранируются в регулярных выражениях, из-за того,
что они ошибочно были экранированы внутри секции C<(?x:...)>.

C<sub foo { foo() }> теперь депарсится с этими обязательными скобками.

C</@array/> теперь депарсится как регулярное выражение, а не просто C<@array>.

C</@{-}/>, C</@{+}/> и C<$#{1}> теперь депарсятся с фигурными скобками, которые
обязательны в этих случаях.

При депарсинге связок фич, C<B::Deparse> выводил сначала C<no feature;>, вместо
вывода C<no feature ':all';>. Это было исправлено.

C<chdir FH> теперь депарсится без кавычек.

C<\my @a> теперь депарсится без скобок. (Скобки выравняют массив).

C<system> и C<exec> с последующим блоком теперь депарсятся корректно. Раньше
появлялся ошибочный C<do> перед блоком.

C<< use constant QR =E<gt> qr/.../flags >> с последующим C<"" =~ QR> больше не
появляются без флагов.

Депарсинг C<BEGIN { undef &foo }> с включённой опцией B<-w> начало выводить
предупреждение о неинициализированности в Perl 5.14. Теперь это было
исправлено.

Вызов депарсинга к подпрограммам с прототипом C<(;+)> приводил к бесконечному
циклу. Прототипы C<(;$>), C<(_)> и C<(;_)> получали неправильный порядок
приоритетов, приводя к депарсингу C<foo($aE<lt>$b)> без скобок.

Deparse теперь предоставляет определённую state подпрограмму во внутренних
подпрограммах.

=item *

Был добавлен L<B::Op_private>

L<B::Op_private> предоставляет детальную информацию о флагах, используемых в
поле C<op_private> опкодов Perl.

=item *

L<bigint>, L<bignum>, L<bigrat> были обновлены до версии 0.39.

Задокументировано в секции CAVEATS (предостережение), что использование строк
как чисел не всегда приводит к перегрузке больших чисел, а также информацию о
том как вызвать её. [rt.perl.org #123064]

=item *

L<Carp> был обновлён до версии 1.36.

C<Carp::Heavy> теперь игнорирует несовпадение версий с Carp, если Carp новее,
чем 1.12, так как начинка C<Carp::Heavy> была внесена в Carp в этой версии.
L<[perl #121574]|https://rt.perl.org/Ticket/Display.html?id=121574>

Carp теперь лучше поддерживает не-ASCII платформы.

Исправлена ошибка на единицу для Perl E<lt> 5.14.

=item *

L<constant> был обновлён до версии 1.33.

Он теперь поддерживает полные имена констант, позволяя определять константы в
пакетах отличных от пакеты вызывающего кода.

=item *

L<CPAN> был обновлён до версии 2.11.

Была добавлена поддержка C<Cwd::getdcwd()> и внесено обходное решение для
ошибочного поведения, которое наблюдалось на Strawberry Perl 5.20.1.

Исправлена ошибка с C<chdir()> после сборки зависимостей.

Введена экспериментальная поддержка для плагинов/хуков.

Интегрированы исходники C<App::Cpan>.

Не проверяется рекурсия для опциональных зависимостей.

Проверка на вменяемость, что F<META.yml> содержит хеш.
L<[cpan #95271]|https://rt.cpan.org/Ticket/Display.html?id=95271>

=item *

L<CPAN::Meta::Requirements> был обновлён до версии 2.132.

Обход ограничения в C<version::vpp> для определения магии v-строк и добавление
поддержки грядущему бутстрапу F<version.pm> в L<ExtUtils::MakeMaker> для Perl
старее чем 5.10.0.

=item *

L<Data::Dumper> был обновлён до версии 2.158.

Исправлена уязвимость CVE-2014-4330 путём добавления переменной
конфигурации или опции для ограничения рекурсии, при выводе глубоко-вложенных
структур.

Изменения для исправления ошибок найденных сканером безопасности Coverity.
XS выводит некорректно сохранённое имя кодовой ссылки, хранимое в GLOB.
L<[perl #122070]|https://rt.perl.org/Ticket/Display.html?id=122070>

=item *

L<DynaLoader> был обновлён до версии 1.32.

Удалена глобальная переменная C<dl_nonlazy>, если не используется в Dynaloader.
[perl #122926]

=item *

L<Encode> был обновлён до версии 2.72.

C<piconv> теперь лучше отлавливает ошибки, когда имя кодировки не существует и
исправлен разлом сборки при обновлении L<Encode> в perl-5.8.2 и более ранних
версий.

Теперь работает сборка в C++ режиме на Windows.

=item *

L<Errno> был обновлён до версии 1.23.

Добавлена опция C<-P> для препроцессора в GCC 5. GCC добавил дополнительную
строковую директиву, которая сломала разбор определений кодов ошибок.
[rt.perl.org #123784]

=item *

L<experimental> был обновлён до версии 0.013.

Зашиты возможности для Perl старше 5.15.7.

=item *

L<ExtUtils::CBuilder> был обновлён до версии 0.280221.

Исправлена регрессия на Android.
L<[perl #122675]|https://rt.perl.org/Ticket/Display.html?id=122675>

=item *

L<ExtUtils::Manifest> был обновлён до версии 1.70.

Исправлена ошибка с обработкой файловых имён с кавычками в C<maniread()> и
улучшен C<manifind()>, теперь следующий по ссылкам.
L<[perl #122415]|https://rt.perl.org/Ticket/Display.html?id=122415>

=item *

L<ExtUtils::ParseXS> был обновлён до версии 3.28.

Объявляет C<file> неиспользуемым только если его действительно определили.
Улучшена генерация кода C<RETVAL>, чтобы избежать повторения ссылок на
C<ST(0)>. [perl #123278]
Расширена и задокументирована typemap оптимизация C</OBJ$/> в C</REF$/> для
метода C<DESTROY>. [perl #123418]

=item *

L<Fcntl> был обновлён до версии 1.13.

Была добавлена поддержка работы с размером буфера канала в Linux в командах
C<fcntl()>.

=item *

L<File::Find> был обновлён до версии 1.29.

C<find()> и C<finddepth()> будут предупреждать, если передана некорректная или
опция с опечаткой.

=item *

L<File::Glob> был обновлён до версии 1.24.

C<SvIV()> избегает расширения для вызова C<get_sv()> три раза в нескольких
местах. [perl #123606]

=item *

L<HTTP::Tiny> был обновлён до версии 0.054.

C<keep_alive> теперь безопасен для вызова fork или запуска новых тредов.

=item *

L<IO> был обновлён до версии 1.35.

XS реализация была исправлена для поддержки работы на старых Perl.

=item *

L<IO::Socket> был обновлён до версии 1.38.

Задокументированы ограничения метода C<connected()>. [perl #123096]

=item *

L<IO::Socket::IP> был обновлён до версии 0.37.

Более лучшее исправление для субкласса C<connect()>.
L<[cpan #95983]|https://rt.cpan.org/Ticket/Display.html?id=95983>
L<[cpan #97050]|https://rt.cpan.org/Ticket/Display.html?id=97050>

Реализован таймаут для C<connect()>.
L<[cpan #92075]|https://rt.cpan.org/Ticket/Display.html?id=92075>

=item *

Коллекция модулей libnet была обновлена до версии 3.05.

Поддержка для IPv6 и SSL для C<Net::FTP>, C<Net::NNTP>, C<Net::POP3> и
C<Net::SMTP>. Улучшения аутентификации в C<Net::SMTP>.

=item *

L<Locale::Codes> был обновлён до версии 3.34.

Исправлен баг в скриптах, используемых для извлечения данных из электронных
таблиц, которые препятствовали поиску SHP коду валюты.
L<[cpan #94229]|https://rt.cpan.org/Ticket/Display.html?id=94229>

Были добавлены новые коды.

=item *

L<Math::BigInt> был обновлён до версии 1.9997.

Синхронизированы изменения в POD вместе со CPAN выпуском.
C<< Math::BigFloat->blog(x) >> иногда возвращает C<blog(2*x)>, когда точность
больше 70 цифр. Результат C<< Math::BigFloat->bdiv() >> в списочном контексте
теперь удовлетворяет C<< x = quotient * divisor + remainder >>.

Исправлена обработка субклассов.
L<[cpan #96254]|https://rt.cpan.org/Ticket/Display.html?id=96254>
L<[cpan #96329]|https://rt.cpan.org/Ticket/Display.html?id=96329>

=item *

L<Module::Metadata> был обновлён до версии 1.000026.

Поддержка инсталляции на старых perl вместе с версиями L<ExtUtils::MakeMaker>
более ранних чем 6.63_03

=item *

L<overload> был обновлён до версии 1.26.

Ненужная проверка C<ref $sub> была удалена.

=item *

Коллекция модулей PathTools была обновлена до версии 3.56.

Избегаются предупреждения компилятора B<gcc> теперь при сборке XS.

C<//> в начале строки не заменяется на C</> на Cygwin. [perl #122635]

=item *

L<perl5db.pl> был обновлён до версии 1.49.

Отладчик вызывал нарушения предположения.
L<[perl #124127]|https://rt.perl.org/Ticket/Display.html?id=124127>

C<fork()> в отладчике в C<tmux> теперь создаёт новое окно для созданного
процесса. L<[perl
#121333]|https://rt.perl.org/Ticket/Display.html?id=121333>

Отладчик теперь сохраняет текущий рабочий каталог при запуске и восстанавливает
его, когда вы перезапускаете вашу программу с помощью C<R> или C<rerun>.
L<[perl #121509]|https://rt.perl.org/Ticket/Display.html?id=121509>

=item *

L<PerlIO::scalar> был обновлён до версии 0.22.

Чтение из позиции за пределами скаляра теперь корректно возвращает конец
файла. [perl #123443]

Смещение в отрицательную позицию по-прежнему приводит к ошибке, но больше не
оставляет позицию на отрицательном смещении.

C<eof()> на C<PerlIO::scalar> дескрипторе теперь корректно возвращает истину,
когда файловая позиция превышает планку в 2 Гбайта на 32-битных системах.

Попытка записи в файловую позицию недопустимую для платформы теперь сразу
приводит к ошибке, а не падает после выделения 4 Гбайт.

=item *

L<Pod::Perldoc> был обновлён до версии 3.25.

Файловые дескрипторы открытые для чтения или записи теперь имеют установленный
C<:encoding(UTF-8)>.
L<[cpan #98019]|https://rt.cpan.org/Ticket/Display.html?id=98019>

=item *

L<POSIX> был обновлён до версии 1.53.

Были добавлены математические функции и константы C99 (например,  C<acosh>,
C<isinf>, C<isnan>, C<round>, C<trunc>; C<M_E>, C<M_SQRT2>, C<M_PI>).

C<POSIX::tmpnam()> теперь выводит предупреждение об устаревшей конструкции.
[perl #122005]

=item *

L<Safe> был обновлён до версии 2.39.

C<reval> не распространял корректно пустой контекст.

=item *

Scalar-List-Utils был обновлён до версии 1.41.

Был добавлен новый модуль L<Sub::Util>, содержащий функции, относящиеся к
кодовым ссылкам, включая C<subname> (по мотивам C<Sub::Identity>) и
C<set_subname> (скопированная и переименованная из C<Sub::Name>).
Использование C<GetMagic> в C<List::Util::reduce()> также было исправлено.
L<[cpan #63211]|https://rt.cpan.org/Ticket/Display.html?id=63211>

=item *

L<SDBM_File> был обновлён до версии 1.13.

Упрощён процесс сборки.  [perl #123413]

=item *

L<Time::Piece> был обновлён до версии 1.29.

При печати отрицательных C<Time::Seconds>, "минус" больше не теряется.

=item *

L<Unicode::Collate> был обновлён до версии 1.12.

Улучшенные несмежные сокращения версии 0.67 сделаны недействительными по
умолчанию и поддерживаются как параметр C<long_contraction>.

=item *

L<Unicode::Normalize> был обновлён до версии 1.18.

Реализация XSUB была удалена, предпочтение отдано реализации на чистом Perl.

=item *

L<Unicode::UCD> был обновлён до версии 0.61.

Была добавлена новая функция L<property_values()|Unicode::UCD/prop_values()>
возвращающая возможные значения для заданного свойства.

Была добавлена новая функция L<charprop()|Unicode::UCD/charprop()>,
возвращающая значение данного свойства по заданной кодовой точке.

Была добавлена новая функция L<charprops_all()|Unicode::UCD/charprops_all()>,
возвращающая значения всех свойств Юникода для заданной кодовой точки.

Исправлен ошибка, когда L<propaliases()|Unicode::UCD/prop_aliases()> возвращает
корректное короткое и длинные имена для Perl расширений, в которых они
некорректны.

Исправлена ошибка, когда
L<prop_value_aliases()|Unicode::UCD/prop_value_aliases()> возвращает C<undef>
вместо некорректного результата для свойств, которые являются Perl расширениями.

Модуль теперь работает на EBCDIC платформах.

=item *

L<utf8> был обновлён до версии 1.17

Было исправлено несоответствие между документацией и кодом в
C<utf8::downgrade()> в соответствии с документацией. Опциональный второй
аргумент теперь корректно интерпретируется как логическое значение (семантика
истина/ложь), а не как целое число.

=item *

L<version> был обновлён до версии 0.9909.

Многочисленные изменения. Смотрите файл F<Changes> в CPAN дистрибутиве.

=item *

L<Win32> был обновлён до версии 0.51.

C<GetOSName()> теперь поддерживает Windows 8.1 и сборку в режиме C++.

=item *

L<Win32API::File> был обновлён до версии 0.1202

Работает сборка в режиме C++.

=item *

L<XSLoader> был обновлён до версии 0.20.

В XSLoader разрешена загрузка модулей их другого пространства имён.
[perl #122455]

=back

=head2 Удалённые модули и прагмы

Следующие модули (и связанные модули) были удалены из базового дистрибутива
perl:

=over 4

=item *

L<CGI>

=item *

L<Module::Build>

=back

=head1 Документация

=head2 Новая документация

=head3 L<perlunicook>

Этот документ, созданный Томом Христиансеном, содержит примеры работы с
Юникодом в Perl.

=head2 Изменения в существующей документации

=head3 L<perlaix>

=over 4

=item *

Было добавлено замечание о long double.

=back


=head3 L<perlapi>

=over 4

=item *

Замечание, что C<SvSetSV> не устанавливает магию.

=item *

C<sv_usepvn_flags> - исправление документации с упоминанием использования
C<Newx> вместо C<malloc>.

L<[perl #121869]|https://rt.perl.org/Ticket/Display.html?id=121869>

=item *

Уточнение, где C<NUL> может быть встроен или требуется для завершения строки.

=item *

Некоторая документация, которая раньше отсутствовала из-за ошибок
форматирования теперь включена.

=item *

Элементы теперь организованы по группам, а не файлам, в которых они находятся.

=item *

Сортировка по алфавиту элементов теперь выполняется согласованно (автоматически
POD-генератором), чтобы быстрее найти данные при поиске.

=back

=head3 L<perldata>

=over 4

=item *

Синтаксис одно-буквенных имён переменных был обновлён и более детально
объяснён.

=item *

Описаны шестнадцатеричные числа с плавающей запятой, а также infinity и NaN.

=back

=head3 L<perlebcdic>

=over 4

=item *

Это документ был значительно обновлён в свете последних улучшений поддержки
платформы EBCDIC.

=back

=head3 L<perlfilter>

=over 4

=item *

Добавлена секция L<LIMITATIONS|perlfilter/LIMITATIONS>.

=back


=head3 L<perlfunc>

=over 4

=item *

Упоминается, что C<study()> на данный момент пустая операция.

=item *

Вызов C<delete> или C<exists> на значения массива теперь описана как
"решительно неприемлемым" вместо "устаревшим".

=item *

Улучшена документация C<< our >>.

=item *

Для C<-l> теперь упоминается, что он возвращает ложь, если символьные ссылки не
поддерживаются файловой системой.

L<[perl #121523]|https://rt.perl.org/Ticket/Display.html?id=121523>

=item *

Замечание, что C<exec LIST> и C<system LIST> могут откатываться в вызов
командной строки на Win32. Только неявный объектный синтаксис C<exec PROGRAM
LIST> и C<system PROGRAM LIST> гарантировано позволит избежать запуск командной
оболочки.

Это также было добавлено в L<perlport>.

L<[perl #122046]|https://rt.perl.org/Ticket/Display.html?id=122046>

=back

=head3 L<perlguts>

=over 4

=item *

Пример с OOK был обновлён с учётом изменений COW и изменений в хранении
смещения.

=item *

Добавлены подробности о символах C-уровня и libperl.t.

=item *

Добавлена информация о работе с Юникодом.

=item *

Добавлена информация о поддержке EBCDIC.

=back

=head3 L<perlhack>

=over 4

=item *

Была добавлена информация о запуске на платформах с набором не-ASCII символов.

=item *

Было добавлено замечание о тестировании производительности

=back

=head3 L<perlhacktips>

=over 4

=item *

Была добавлена документация, иллюстрирующая риски самонадеянности, что нет
изменений в содержимом статической памяти, на которую указывает возвращаемое
значение Perl-обёртки для библиотечных C-функций.

=item *

Замены для C<tmpfile>, C<atoi>, C<strtol> и C<strtoul> теперь рекомендуются.

=item *

Обновлена документация для цели C<make> C<test.valgrind>.

L<[perl #121431]|https://rt.perl.org/Ticket/Display.html?id=121431>

=item *

Дана информация о написании файлов тестов переносимых на не-ASCII платформы. 

=item *

Была добавлено заметка о том, как получить трассировку стека вызовов языка C.

=back

=head3 L<perlhpux>

=over 4

=item *

Замечание о том, что сообщение "Повторное объявление "sendpath" с отличающимся
описанием класса хранения" безобидно.

=back

=head3 L<perllocale>

=over 4

=item *

Обновлено данными об улучшениях, появившихся в v5.22, вместе с некоторыми
пояснениями.

=back

=head3 L<perlmodstyle>

=over 4

=item *

Вместо указания на список модулей, мы теперь указываем на
L<PrePAN|http://prepan.org/>.

=back

=head3 L<perlop>

=over 4

=item *

Обновлено данными об улучшениях, появившихся в v5.22, вместе с некоторыми
пояснениями.

=back

=head3 L<perlpodspec>

=over 4

=item *

Спецификация языка pod изменена, кодировка по умолчанию для pod, которые не
в UTF-8 (или иначе обозначенные), теперь CP1252 вместо ISO 8859-1 (Latin1).

=back

=head3 L<perlpolicy>

=over 4

=item *

Теперь у нас есть правила поведения для почтового списка рассылки I<< p5p >>,
задокументированные в L<< perlpolicy/STANDARDS OF CONDUCT >>.

=item *

Указаны условия, при которых экспериментальные возможности перестают быть
экспериментальными.

=item *

Были сделаны уточнения по типам изменений, которые допустимы в релизах
сопровождения.

=back

=head3 L<perlport>

=over 4

=item *

Устаревшая специфичная для VMS информация была исправлена и/или упрощена.

=item *

Были добавлены замечания о EBCDIC.

=back

=head3 L<perlre>

=over 4

=item *

Было уточнено описание модификатора C</x>, чтобы отметить, что комментарии не
могут быть продолжены на следующей строке путём экранирования их; кроме того
теперь есть список всех символов, которые рассматриваются этим модификатором
как пробельные.

=item *

Описан новые модификатор C</n>.

=item *

Было добавлено заметка о том, как сделать классы символов, обособленные
скобками, переносимыми на не-ASCII машины.

=back

=head3 L<perlrebackslash>

=over 4

=item *

Добавлена документация по C<\b{sb}>, C<\b{wb}>, C<\b{gcb}> и C<\b{g}>.

=back

=head3 L<perlrecharclass>

=over 4

=item *

Были добавлены пояснения в L<perlrecharclass/Character Ranges> об эффекте
C<[A-Z]>, C<[a-z]>, C<[0-9]> и любых поддиапазонов в обособленных скобками
классах символов в регулярных выражениях, который гарантирует, что произойдёт
совпадение только с тем, что ожидает неподготовленный англоговорящий
пользователь, даже на платформах (таких как EBCDIC), где требуется специальные
манипуляции для достижения этой цели.

=item *

Документация обособленных скобками классов символов была расширена, осветив
улучшения в C<qr/[\N{named sequence}]/> (смотрите L</Selected Bug Fixes>).

=back

=head3 L<perlref>

=over 4

=item *

Была добавлена новая секция L<Присвоение ссылкам|perlref/Assigning to References>

=back

=head3 L<perlsec>

=over 4

=item *

Были добавлены комментарии об алгоритмической сложности и связанных хешах.

=back

=head3 L<perlsyn>

=over 4

=item *

Была исправлена неоднозначность в документации, касаемая оператора C<...>.
L<[perl #122661]|https://rt.perl.org/Ticket/Display.html?id=122661>

=item *

Пустое условие в C<< for >> и C<< while >> теперь задокументировано в L<<
perlsyn >>.

=back

=head3 L<perlunicode>

=over 4

=item *

Документация была значительно переработана для соответствия с текущей
поддержкой Юникода и, чтобы сделать её более читабельной. Заметно, что Юникод
7.0 изменил поведение в отношении не-символов. Perl сохранил старый способ
работы по причинам обратной совместимости. Смотрите
L<perlunicode/Noncharacter code points>.

=back

=head3 L<perluniintro>

=over 4

=item *

Был обновлён совет о том, как быть уверенным, что строки и шаблоны регулярных
выражений интерпретируются как Юникод.

=back

=head3 L<perlvar>

=over 4

=item *

C<$]> больше не считается устаревшей. Вместо этого была добавлено обсуждение о
преимуществах и недостатках использования её вместо C<$^V>.

=item *

C<${^ENCODING}> теперь считается устаревшей.

=item *

Была уточнена запись о C<%^H> для указания, что она может хранить только
простые значения.

=back

=head3 L<perlvms>

=over 4

=item *

Устаревший и/или некорректный материал был удалён.

=item *

Обновлена документация об окружении и взаимодействии с оболочкой на VMS.

=back

=head3 L<perlxs>

=over 4

=item *

Добавлено обсуждение о проблемах с локалью в XS коде.

=back

=head1 Диагностика

Следующие добавления и изменения были сделаны в диагностическом выводе, включая
предупреждения и фатальные сообщения об ошибках. Для полного перечная
диагностических сообщений смотрите L<perldiag>.

=head2 Новая диагностика

=head3 Новые ошибки

=over 4

=item *

L<Bad symbol for scalar|perldiag/"Bad symbol for scalar">

(P) Внутренний запрос попросил добавить скалярную запись к чему-то, что не
является записью в таблице символов.

=item *

L<Can't use a hash as a reference|perldiag/"Can't use a hash as a reference">

(F) Вы попытались использовать хеш как ссылку, например, C<< %foo->{"bar"} >>
или C<< %$ref->{"hello"} >>. Версии perl E<lt>= 5.6.1 разрешали подобный
синтаксис, хотя этого не следовало делать.

=item *

L<Can't use an array as a reference|perldiag/"Can't use an array as a reference">

(F) Вы попытались использовать массив как ссылку, например, C<< @foo->[23] >>
или C<< @$ref->[99] >>. Версии perl E<lt>= 5.6.1 разрешали подобный
синтаксис, хотя этого не следовало делать.

=item *

L<Can't use 'defined(@array)' (Maybe you should just omit the defined()?)|perldiag/"Can't use 'defined(@array)' (Maybe you should just omit the defined()?)">

(F) C<defined()> бесполезен для массивов поскольку он проверяет на
неопределённость значение I<скаляра>. Если вы хотите проверить является ли
массив пустым просто используйте, например, S<C<if (@array) { # не пустой }>>.

=item *

L<Can't use 'defined(%hash)' (Maybe you should just omit the defined()?)|perldiag/"Can't use 'defined(%hash)' (Maybe you should just omit the defined()?)">

(F) C<defined()> не совсем то, что нужно для хешей.

Хотя S<C<defined %hash>> является ложью на простом неиспользованном хеше, это
становится истиной в некоторых неочевидных случаях, включая использования
итераторов, слабых ссылок, имён стэшей и даже остаётся истиной после
S<C<undef %hash>>. Это делает S<C<defined %hash>> довольно бесполезным на
практике, поэтому сейчас он вызывает фатальную ошибку.

Если вам требуется проверка на то, что хеш не пустой, просто поставьте его в
логический контекст (смотрите L<perldata/Scalar values>):

    if (%hash) {
       # not empty
    }

Если вы использовали S<C<defined %Foo::Bar::QUUX>> для проверки, что существует
подобная переменная пакета, то это никогда не было надёжно и не является
правильным путём запроса о возможностях пакета или проверки того, что он
загружен и так далее.

=item *

L<Cannot chr %f|perldiag/"Cannot chr %f">

(F) Вы передали некорректное число (например, бесконечность или не-число) в
C<chr>.

=item *

L<Cannot compress %f in pack|perldiag/"Cannot compress %f in pack">

(F) Вы пытались конвертировать бесконечность или не-число в беззнаковый символ,
что является бессмысленным.

=item *

L<Cannot pack %f with '%c'|perldiag/"Cannot pack %f with '%c'">

(F) Вы пытались конвертировать бесконечность или не-число в символ, что
является бессмысленным.

=item *

L<Cannot print %f with '%c'|perldiag/"Cannot printf %f with '%c'">

(F) Вы попытались напечатать бесконечность или не-число как символ (C<%c>), что
не имеет смысла. Возможно вы имели ввиду C<'%s'> или просто привести его к
строковому виду.

=item *

L<charnames alias definitions may not contain a sequence of multiple spaces|perldiag/"charnames alias definitions may not contain a sequence of multiple spaces">

(F) Вы определили имя символа, который имеет несколько пробельных символов
подряд. Замените их на один пробел. Обычно эти имена определены в аргументе
импорта C<:alias> для C<use charnames>, но они также могут быть определены
переводчиком и располагаться в C<$^H{charnames}>.
Смотрите L<charnames/CUSTOM ALIASES>.

=item *

L<charnames alias definitions may not contain trailing white-space|perldiag/"charnames alias definitions may not contain trailing white-space">

(F) Вы определили имя символа, который завершается на пробельный символ.
Удалите завершающий пробел. Обычно эти имена определены в аргументе
импорта C<:alias> для C<use charnames>, но они также могут быть определены
переводчиком и располагаться в C<$^H{charnames}>.
Смотрите L<charnames/CUSTOM ALIASES>.

=item *

L<:const is not permitted on named subroutines|perldiag/":const is not permitted on named subroutines">

(F) Атрибут C<const> используется, чтобы анонимная подпрограмма запускалась и
захватывала значение в тоже время, в которое оно клонируется. Именованная
подпрограмма не может быть клонирована подобным образом, поэтому атрибут для
неё не имеет смысла.

=item *

L<Hexadecimal float: internal error|perldiag/"Hexadecimal float: internal error">

(F) Произошло нечто ужасное в обработке шестнадцатеричного значения с плавающей
запятой.

=item *

L<Hexadecimal float: unsupported long double format|perldiag/"Hexadecimal float: unsupported long double format">

(F) Вы сконфигурировали Perl для использования long double, но внутренняя
реализация формата long double неизвестна, поэтому вывод шестнадцатеричного
значения с плавающей запятой невозможен.

=item *

L<Illegal suidscript|perldiag/"Illegal suidscript">

(F) Запуск скрипта под suidperl уже давно нелегален.

=item *

L<In '(?...)', the '(' and '?' must be adjacent in regex; marked by S<<-- HERE> in mE<sol>%sE<sol>|perldiag/"In '(?...)', the '(' and '?' must be adjacent in regex; marked by <-- HERE in m/%s/">

(F) Двухсимвольная последовательность C<"(?"> в этом контексте в шаблоне
регулярного выражения должно быть неделимой лексемой и ничего не может
находиться между C<"("> и C<"?">, но вы разделили их.

=item *

L<In '(*VERB...)', the '(' and '*' must be adjacent in regex; marked by S<<-- HERE> in mE<sol>%sE<sol>|perldiag/"In '(*VERB...)', the '(' and '*' must be adjacent in regex; marked by <-- HERE in m/%s/">

(F) Двухсимвольная последовательность C<"(*"> в этом контексте в шаблоне
регулярного выражения должно быть неделимой лексемой и ничего не может
находиться между C<"("> и C<"*">, но вы разделили их.

=item *

L<Invalid quantifier in {,} in regex; marked by <-- HERE in mE<sol>%sE<sol>|perldiag/"Invalid quantifier in {,} in regex; marked by <-- HERE in m/%s/">

(F) Шаблон выглядит как квантор {min,max}, но min или max не могут быть
распарсены как валидные числа: либо они имеют нули, стоящие в начале, либо
представляют слишком большие числа, чтобы можно работать с ними. S<<-- HERE>
показывает где в регулярном выражении найдена эта проблема. Смотрите L<perlre>.

=item *

L<'%s' is an unknown bound type in regex|perldiag/"'%s' is an unknown bound type in regex; marked by <-- HERE in m/%s/">

Вы использовали C<\b{...}> или C<\B{...}>, но C<...> неизвестен Perl. Текущие
допустимые варианты описаны в L<perlrebackslash/\b{}, \b, \B{}, \B>.

=item *

L<Missing or undefined argument to require|perldiag/Missing or undefined argument to require>

(F) Вы пытались вызвать C<require> без аргумента или с неопределённым значением
в качестве аргумента. C<require> ожидает имя пакета или указание на файл в
качестве аргумента. Смотрите L<perlfunc/require>.

Раньше C<require> без аргумента или с C<undef> предупреждала о пустом имени
файла.

=back

=head3 Новые предупреждения

=over 4

=item *

L<\C is deprecated in regex|perldiag/"\C is deprecated in regex; marked by <-- HERE in m/%s/">

(D deprecated) Класс символов C<< /\C/ >> был объявлен устаревшим в v5.20 и
теперь выводит предупреждение. Предполагается, что это станет ошибкой в v5.24.
Этот класс символов совпадает с единичным байтом, даже если он появляется
внутри многобайтовой последовательности, что нарушает инкапсуляцию и может
повреждать UTF-8 строки.

=item *

L<"%s" is more clearly written simply as "%s" in regex; marked by E<lt>-- HERE in mE<sol>%sE<sol>|perldiag/"%s" is more clearly written simply as "%s" in regex; marked by <-- HERE in mE<sol>%sE<sol>>

(W regexp) (только при действии C<S<use re 'strict'>> или внутри C<(?[...])>).

Вы указали символ, который имеет указанный более простой способ записи и
который переносим между платформами, работающими с разными наборами символов.

=item *

L<Argument "%s" treated as 0 in increment (++)|perldiag/"Argument "%s" treated
as 0 in increment (++)">

(W numeric) Указанная строка была передана как аргумент оператору C<++>, который
ожидает либо число, либо строку, совпадающую с C</^[a-zA-Z]*[0-9]*\z/>.
Смотрите подробности в L<perlop/Auto-increment and Auto-decrement>.

=item *

L<Both or neither range ends should be Unicode in regex; marked by E<lt>-- HERE in mE<sol>%sE<sol>|perldiag/"Both or neither range ends should be Unicode in regex; marked by <-- HERE in m/%s/">

(W regexp) (только при действии C<S<use re 'strict'>> или внутри C<(?[...])>).

В классе символов, обособленных скобками, в шаблоне регулярного выражения у вас
используется диапазон, который имеет одну из границ, указанной с использованием
C<\N{}>, а другая граница указана с помощью непереносимого механизма. Perl
рассматривает этот диапазон, как Юникод-диапазон, в котором все символы
являются Юникод-символами и которые могут иметь различные кодовые значения на
некоторых платформах, на которых работает Perl. Например, C<[\N{U+06}-\x08]>
рассматривается как если бы написали C<[\N{U+06}-\N{U+08}]>, который совпадает
с символами, чьи кодовые значения в Юникоде соответственно 6, 7 и 8. Но C<\x08>
может означать что-то другое, поэтому выводится предупреждение.

=item *

L<Can't do %s("%s") on non-UTF-8 locale; resolved to "%s".|perldiag/Can't do %s("%s") on non-UTF-8 locale; resolved to "%s".>

(W locale) Вы 1) работаете при действии "C<use locale>"; 2) текущая локаль не
является UTF-8; 3) вы пытались сделать операцию изменения регистра на указанном
Юникод символе; и 4) результат этой операции приведёт к смешиванию правил
Юникода и локали, которые вероятно конфликтуют.

=item *

L<:const is experimental|perldiag/":const is experimental">

(S experimental::const_attr) Атрибут C<const> является экспериментальным.
Если вы хотите использовать эту возможность, подавите предупреждения с помощью
C<no warnings 'experimental::const_attr'>, но имейте ввиду, что вы принимаете
на себя риск, что ваш код может сломаться в будущих версиях Perl.

=item *

L<gmtime(%f) failed|perldiag/"gmtime(%f) failed">

(W overflow) вы вызвали C<gmtime> с числом, которое невозможно обработать:
слишком большое, слишком маленькое или NaN. Возвращаемое значение - C<undef>.

=item *

L<Hexadecimal float: exponent overflow|perldiag/"Hexadecimal float: exponent overflow">

(W overflow) Шестнадцатеричное значение с плавающей запятой имеет экспоненту
бо́льше, чем поддерживается форматом плавающей запятой.

=item *

L<Hexadecimal float: exponent underflow|perldiag/"Hexadecimal float: exponent underflow">

(W overflow) Шестнадцатеричное значение с плавающей запятой имеет экспоненту
меньше, чем поддерживается форматом плавающей запятой.

=item *

L<Hexadecimal float: mantissa overflow|perldiag/"Hexadecimal float: mantissa overflow">

(W overflow) Шестнадцатеричное значение с плавающей запятой имеет больше бит в
мантиссе (часть между C<0x> и экспонентой, также известную как значащие цифры),
чем поддерживается форматом плавающей запятой.

=item *

L<Hexadecimal float: precision loss|perldiag/"Hexadecimal float: precision loss">

(W overflow) Шестнадцатеричное значение с плавающей запятой имеет внутреннее
представление с большим числом цифр, чем может быть выведено. Это может быть
вызвано неподдерживаемым форматом long double или 64-битными целыми, которые
недоступны (требуемые для получения цифр не некоторых конфигурациях).

=item *

L<Locale '%s' may not work well.%s|perldiag/Locale '%s' may not work well.%s>

(W locale) Вы используется именованную локаль, которая не является UTF-8,
которую Perl определил как не полностью совместимую с Perl. Второй C<%s>
указывает на причину.

=item *

L<localtime(%f) failed|perldiag/"localtime(%f) failed">

(W overflow) Вы вызвали C<localtime> с числом, которое не может быть
обработано: слишком большое, слишком маленькое или NaN. Возвращаемым значением
является C<undef>.

=item *

L<Negative repeat count does nothing|perldiag/"Negative repeat count does nothing">

(W numeric) Вы пытались выполнить оператор повторения
L<C<x>|perlop/Multiplicative Operators> меньше чем 0 раз, что не имеет смысла.

=item *

L<NO-BREAK SPACE in a charnames alias definition is deprecated|perldiag/"NO-BREAK SPACE in a charnames alias definition is deprecated">

(D deprecated) Вы определили имя символа, содержащий неразрывный символ
пробела. Замените его на обычный пробел. Обычно подобные имена определены в
аргументе импорта C<:alias> для C<use charnames>, но они могут быть определены
переводчиком в C<$^H{charnames}>. Смотрите L<charnames/CUSTOM ALIASES>.

=item *

L<Non-finite repeat count does nothing|perldiag/"Non-finite repeat count does nothing">

(W numeric) Вы попытались выполнить оператор повторения
L<C<x>|perlop/Multiplicative Operators> C<Inf> (или C<-Inf>) раз, что не имеет
смысла.

=item *

L<PerlIO layer ':win32' is experimental|perldiag/"PerlIO layer ':win32' is experimental">

(S experimental::win32_perlio) Слой PerlIO C<:win32> является
экспериментальным. Если вы готовы принять риск его использования просто
отключите предупреждение:

    no warnings "experimental::win32_perlio";

=item *

L<Ranges of ASCII printables should be some subset of "0-9", "A-Z", or "a-z" in regex; marked by E<lt>-- HERE in mE<sol>%sE<sol>|perldiag/"Ranges of ASCII printables should be some subset of "0-9", "A-Z", or "a-z" in regex; marked by <-- HERE in mE<sol>%sE<sol>">

(W regexp) (только при действии C<S<use re 'strict'>> или внутри C<(?[...])>).

Строгие правила позволяют найти опечатки и другие ошибки. Возможно вы даже и не
планировали использовать здесь диапазон, если под C<"-"> понимался другой
символ или он должен был быть экранирован (C<"\-">). Если вы подразумевали
диапазон, то то, что было использовано не является переносимым между ASCII и
EBCDIC платформами и не имеют очевидного смысла для случайного читателя.

 [3-7]    # OK; Очевидно и переносимо
 [d-g]    # OK; Очевидно и переносимо
 [A-Y]    # OK; Очевидно и переносимо
 [A-z]    # Неправильно; Непереносимо; непонятно, что имелось ввиду
 [a-Z]    # Неправильно; Непереносимо; непонятно, что имелось ввиду
 [%-.]    # Неправильно; Непереносимо; непонятно, что имелось ввиду
 [\x41-Z] # Неправильно; Непереносимо; непонятно для не-гика

(Вы можете улучшить переносимость, указав Юникод-диапазон, что означает, что
точки указываются с использованием L<C<\N{...}>|perlrecharclass/Character
Ranges>, но смысл может быть по-прежнему неочевиден.
Строгие правила требуют, чтобы диапазоны, которые начинаются или заканчиваются
ASCII символом, которые не являются контрольными, чтобы все крайние значения
были литеральными символами, а не экранирующими последовательностями (как
например, C<"\x41">) и диапазоны должны состоять только из всех цифр, всех букв
в верхнем регистре или всех букв в нижем регистре.

=item *

L<Ranges of digits should be from the same group in regex; marked by E<lt>-- HERE in mE<sol>%sE<sol>|perldiag/"Ranges of digits should be from the same group in regex; marked by <-- HERE in m/%s/">

(W regexp) (только при действии C<S<use re 'strict'>> или внутри C<(?[...])>)

Строгие правила помогают найти опечатки или ошибки. Вы включили диапазон и одна
из его границ является десятичной цифрой. При строгих правилах, когда такое
происходит, обе границы должны быть цифрами в той же самой группе из 10
последовательных цифр.

=item *

L<Redundant argument in %s|perldiag/Redundant argument in %s>

(W redundant) Вы вызвали функцию с большим числом аргументов, чем требовалось,
как показывает информация внутри других аргументов, которые вы передали
(например, формат printf). На данный момент выводится, когда printf-подобный
формат требует меньше аргументов, чем было передано, но может использоваться в
будущем для, например, <perlfunc/pack>.

Категория предупреждений C<< redundant >> (излишний) является новой. Смотрите
также L<[perl #121025]|https://rt.perl.org/Ticket/Display.html?id=121025>.

=item *

L<Replacement list is longer than search list|perldiag/Replacement list is longer than search list>

Это не новое диагностическое сообщение, но в ранних релизах оно не
отображалось, если транслитерация содержала широкие символы. Теперь это
исправлено, поэтому вы можете увидеть это сообщение в местах, в которых раньше
вы его не видели (но должны были бы).

=item *

L<Use of \b{} for non-UTF-8 locale is wrong.  Assuming a UTF-8 locale|perldiag/"Use of \b{} for non-UTF-8 locale is wrong.  Assuming a UTF-8 locale">

(W locale) Вы используете регулярное выражение с правилами локали, произошло
совпадение с Юникод-границей, при этом локаль не является Юникодной. Это не
имеет смысла.  Perl продолжит, подразумевая Юникод (UTF-8) локаль, но
результаты могут быть некорректными за исключением если локаль оказалась
ISO-8859-1 (Latin1), где это сообщение ложное и может быть проигнорировано.

Категория предупреждений C<locale> является новой.

=item *

L<< Using E<sol>u for '%s' instead of E<sol>%s in regex; marked by E<lt>-- HERE in mE<sol>%sE<sol>|perldiag/"Using E<sol>u for '%s' instead of E<sol>%s in regex; marked by <-- HERE in mE<sol>%sE<sol>" >>

(W regexp) Вы использовали Юникод границу (C<\b{...}> или C<\B{...}>) в части
регулярного выражения, где действуют модификаторы C</a> или C</aa>. Эти два
модификатора указывают на ASCII интерпретацию и это лишено смысла для Юникод
определения.  Сгенерированное регулярное выражение будет собрано так, что все
границы будут использовать Юникод. Другие части регулярного выражения затронуты
не будут.

=item *

L<The bitwise feature is experimental|perldiag/"The bitwise feature is experimental">

(S experimental::bitwise) Это предупреждение выводится, если вы использовали
битовые операторы (C<& | ^ ~ &. |. ^. ~.>) с включённой возможностью "bitwise".
Просто подавите это предупреждение, если вы хотите использовать эту
возможность, но учтите, что в этом случае вы берёте на себя риск использования
экспериментальной возможности, которая может измениться или быть удалённой в
будущих версиях Perl:

    no warnings "experimental::bitwise";
    use feature "bitwise";
    $x |.= $y;

=item *

L<Unescaped left brace in regex is deprecated, passed through in regex; marked by <-- HERE in mE<sol>%sE<sol>|perldiag/"Unescaped left brace in regex is deprecated, passed through in regex; marked by <-- HERE in m/%s/">

(D deprecated, regexp) Вы использовали литеральный символ C<"{"> в шаблоне
регулярного выражения. Вы должны заменить его на C<"\{">, поскольку в будущих
версиях Perl (ориентировочно v5.26) это будет расцениваться как синтаксическая
ошибка. Если разделитель шаблона также является фигурной скобкой, то любая
совпадающая правая скобка (C<"}">) также должна быть экранирована, чтобы
не запутывать парсер, например:

    qr{abc\{def\}ghi}

=item *

L<Use of literal non-graphic characters in variable names is deprecated|perldiag/"Use of literal non-graphic characters in variable names is deprecated">

(D deprecated) Использование литеральных неграфических символов (включая
контрольные) в исходном коде для ссылки на I<^FOO> переменные, например C<$^X>
и C<${^GLOBAL_PHASE}> теперь считается устаревшим.

=item *

L<Useless use of attribute "const"|perldiag/Useless use of attribute "const">

(W misc) Атрибут C<const> действует только на анонимные прототипы замыканий. Вы
применил их к подпрограмме через L<attributes.pm|attributes>. Это имеет смысл
только внутри атрибутов анонимной подпрограммы.

=item *

L<Useless use of E<sol>d modifier in transliteration operator|perldiag/"Useless use of /d modifier in transliteration operator">

Это не новое диагностическое сообщение, но в ранних релизах оно не
отображалось, если транслитерация содержала широкие символы. Теперь это
исправлено, поэтому вы можете увидеть это сообщение в местах, в которых раньше
вы его не видели (но должны были бы).

=item *

L<E<quot>use re 'strict'E<quot> is experimental|perldiag/"use re 'strict'" is experimental>

(S experimental::re_strict) Отличия в поведении, когда шаблон регулярных
выражений компилируется при действии C<'strict'>, могут меняться в будущих
релизах Perl несовместимом образом; есть также предложения изменить способ
включения строгой проверки вместо использования субпрагмы. Это означает, что
шаблон, который компилируется сегодня, не будет компилироваться в будущих
версиях Perl. Это предупреждение сигнализирует вам об этом риске.

=item *

L<Warning: unable to close filehandle properly: %s|perldiag/"Warning: unable to close filehandle properly: %s">

L<Warning: unable to close filehandle %s properly: %s|perldiag/"Warning: unable to close filehandle %s properly: %s">

(S io) Раньше Perl молча игнорировал любые ошибки, когда делал неявное закрытие
файлового дескриптора, то есть там, где счётчик ссылок файлового дескриптора
достигал нуля и код пользователя ещё не вызывал C<close()>; например:

    {
        open my $fh, '>', $file  or die "open: '$file': $!\n";
        print $fh, $data  or die;
    } # здесь неявное закрытие

В ситуациях, когда диск полон, из-за буферизации, ошибка могла быть обнаружена
только во время финального закрытия, таким образом, отсутствие проверки
результатов закрытия может быть опасно.

Теперь Perl предупреждает о подобных ситуациях.

=item *

L<Wide character (U+%X) in %s|perldiag/"Wide character (U+%X) in %s">

(W locale) При использовании однобайтовойлокали (I<то есть>, не UTF-8), был
обнаружен многобайтовый символ. Perl рассматривает этот символ, как указанная
кодовая точка Юникод. Комбинация не-UTF-8 локалей и Юникода опасна. Почти
наверняка некоторые символы будут иметь разное представление. Например, в
локали ISO 8859-7 (Греческая), кодовая точка 0xC3 представляет заглавную гамму.
Но тем же самым является 0x393. Это делает сравнение строк ненадёжным.

Вы должны найти как этот многобайтовый символ смешался с вашей однобайтной
локалью (возможно вы думали, что у вас UTF-8 локаль, но Perl с этим не
согласился).

Категория предупреждений C<locale> является новой.

=back

=head2 Изменения в существующей диагностике

=over 4

=item *

<> должны быть кавычки

Это предупреждение изменилось на 
L<< <> at require-statement should be quotes|perldiag/"<> для оператора require должны быть кавычками" >>,
чтобы сделать сообщение более идентичным.

=item *

L<Argument "%s" isn't numeric%s|perldiag/"Argument "%s" isn't numeric%s">

В записи L<perldiag> для этого предупреждения было внесено пояснение:

 Обратите внимание, что для Inf и NaN (бесконечность и не-число) опередление
 "числовой" нечто необычное; строка сами по себе (например, "Inf")
 рассматриваются как числовые, а всё, что следует за нами рассматривается как
 нечисловое значение.

=item *

L<Global symbol "%s" requires explicit package name|perldiag/"Global symbol "%s" requires explicit package name (did you forget to declare "my %s"?)">

К этому сообщению было добавлено '(did you forget to declare "my %s"?)' (не
забыли ли вы сделать объявление "my %s"?), чтобы сделать его более полезным для
начинающих Perl программистов.
L<[perl #121638]|https://rt.perl.org/Ticket/Display.html?id=121638>

=item *

Сообщение 'переменная "my" &foo::bar не может быть в пакете' было переработано,
используя слово 'подпрограмма" вместо 'переменная'.

=item *

L<<< \N{} in character class restricted to one character in regex; marked by
S<< <-- HERE >> in mE<sol>%sE<sol>|perldiag/"\N{} in inverted character
class or as a range end-point is restricted to one character in regex;
marked by <-- HERE in m/%s/" >>>

В этом сообщении I<character class> (класс символа) был изменён на I<inverted character
class or as a range end-point is> (инвертированный символьный класс или как
граница диапазона), чтобы отметить улучшение в 
C<qr/[\N{named sequence}]/> (смотрите в L</Selected Bug Fixes>).

=item *

L<panic: frexp|perldiag/"panic: frexp: %f">

К этому сообщению было добавлено ': C<%f>', чтобы показать виновное число с
плавающей запятой.

=item *

I<Possible precedence problem on bitwise %c operator> перефразировано
L<Possible precedence problem on bitwise %s operator|perldiag/"Possible precedence problem on bitwise %s operator">.

=item *

L<Unsuccessful %s on filename containing newline|perldiag/"Unsuccessful %s on filename containing newline">

Это предупреждение теперь выводится, только если есть перевод строки в конце
имени файла.

=item *

"Variable C<%s> will not stay shared" (переменная C<%s> перестанет быть
разделённой) было изменено, чтобы сказать "Subroutine" (подпрограмма), когда
используется лексическая подпрограмма, которая перестанет быть разделённой.

=item *

L<Variable length lookbehind not implemented in regex mE<sol>%sE<sol>|perldiag/"Variable length lookbehind not implemented in regex m/%s/">

Запись в L<perldiag> для этого предупреждения имеет информацию о добавленном
поведении Юникода.

=back

=head2 Удалённые диагностические сообщения

=over

=item *

"Ambiguous use of -foo resolved as -&foo()"

Здесь нет никакой неопределённости и это мешает использовать отрицательные
значения констант, например, C<-Inf>.

=item *

"Constant is not a FOO reference"

Было удалено разыменование констант (например, C<< my_constant->() >>)
во время компиляции, поскольку не учитывалась возможная перегрузка.
L<[perl #69456]|https://rt.perl.org/Ticket/Display.html?id=69456>
L<[perl #122607]|https://rt.perl.org/Ticket/Display.html?id=122607>

=back

=head1 Изменения в утилитах

=head2 Удаление F<find2perl>, F<s2p> и F<a2p>

=over 4

=item *

Директория F<x2p/> была удалена из базового Perl.

Это привело к удалению find2perl, s2p и a2p. Они все выпущены на CPAN как
отдельные дистрибутивы (C<App::find2perl>, C<App::s2p>, C<App::a2p>).

=back

=head2 L<h2ph>

=over 4

=item *

F<h2ph> теперь поддерживает шестнадцатеричные константы в предопределённых
компилятором макро-определениях, как видимые в C<$Config{cppsymbols}>.
L<[perl #123784]|https://rt.perl.org/Ticket/Display.html?id=123784>.

=back

=head2 L<encguess>

=over 4

=item *

Больше не зависит от не базовых модулей.

=back

=head1 Конфигурация и компиляция

=over 4

=item *

F<Configure> теперь проверяет наличие C<lrintl()>, C<lroundl()>, C<llrintl()> и
C<llroundl()>.

=item *

F<Configure> с C<-Dmksymlinks> теперь должен быть быстрее.
L<[perl #122002]|https://rt.perl.org/Ticket/Display.html?id=122002>.

=item *

Библиотеки C<pthreads> и C<cl> будут слинкованы, если присутствуют при сборке.
Это позволит XS модулям, которым требуются треды для работы на perl без
поддержки тредов. Обратите внимание, что вам по-прежнему требуется передавать
аргумент C<-Dusethreads>, если требуется поддержка тредов в perl.

=item *

Для long double (чтобы получить больше точности и диапазона чисел с плавающей
запятой) можно использовать библиотеку GCC quadmath, которая реализует
четырёхкратную точность чисел с плавающей запятой на платформах x86 и IA-64.
Смотрите подробности в F<INSTALL>.

=item *

MurmurHash64A и MurmurHash64B могут быть сконфигурированы как внутренняя
хеш-функция.

=item *

C<make test.valgrind> теперь поддерживает параллельное тестирование.

Например:

    TEST_JOBS=9 make test.valgrind

Смотрите подробности в L<perlhacktips/valgrind>.

L<[perl #121431]|https://rt.perl.org/Ticket/Display.html?id=121431>

=item *

Опция сборки MAD (различные украшения атрибутов) была удалена

Это ныне не поддерживаемая попытка сохранения распарсеного дерева Perl более
точным, чтобы была возможность сделать автоматическую конверсию Perl 5 в Perl 6
более простой.

Эта опция конфигурации не сопровождается уже много лет и вероятно уже серьёзно
отклонилась от актуальности с обеих сторон: как Perl 5, так и Perl 6.

=item *

Доступен новый флаг компиляции C<< -DPERL_OP_PARENT >>. Больше информации в
дискуссии выше в L<< /Internal Changes >>.

=item *

Pathtools больше не пытаются загрузить XS на miniperl. Это значительно ускоряет
сборку perl.

=back

=head1 Тестирование

=over 4

=item *

Был добавлен F<t/porting/re_context.t> для проверки, что L<utf8> и его
зависимости являются только подмножество переменных захвата C<$1..$n>, которые
зашиты в C<Perl_save_re_context()> для локализации, поскольку в этой функции
нет эффективной возможности во время исполнения определить какие переменные
локализованы.

=item *

Тесты на производительность были добавлены в файл F<t/perf/taint.t>.

=item *

Некоторые тесты регулярных выражений написаны так, что они будут работать очень
медленно, если какие-то определённые оптимизации окажутся сломанными. Эти тесты
были перенесены в новые файлы F<< t/re/speed.t >> и F<< t/re/speed_thr.t >>, и
они запускаются с использованием C<< watchdog() >>.

=item *

C<< test.pl >> теперь разрешает C<< plan skip_all => $reason >>, чтобы сделать
его более совместимым с C<< Test::More >>.

=item *

Был добавлен новый тестовый скрипт F<op/infnan.t> для тестирования, что
бесконечность и не-числа работают корректно. Смотрите 
L</Infinity and NaN (not-a-number) handling improved>.

=back

=head1 Поддержка платформ

=head2 Восстановленные платформы

=over 4

=item Платформы IRIX и Tru64 снова работают.

Остаются несколько ошибок во время C<make test>:
L<[perl #123977]|https://rt.perl.org/Ticket/Display.html?id=123977>
и L<[perl #125298]|https://rt.perl.org/Ticket/Display.html?id=125298>
для IRIX; L<[perl #124212]|https://rt.perl.org/Ticket/Display.html?id=124212>,
L<[cpan #99605]|https://rt.cpan.org/Public/Bug/Display.html?id=99605>, и
L<[cpan #104836|https://rt.cpan.org/Ticket/Display.html?id=104836> для Tru64.

=item Работа z/OS с кодовой страницей 1047 EBCDIC

Базовый perl теперь работает на этой EBCDIC платформе. Ранние версии также
работали, но несмотря на то, что официально поддержка не была отозвана,
последние версии Perl не компилировались и не работали нормально. Perl 5.20 в
целом работал, но имел множество багов, который теперь были исправлены.
Множество CPAN модулей, которые поставляются с Perl по-прежнему не проходят
тесты, включая и C<Pod::Simple>. Однако версия C<Pod::Simple> на CPAN должна
работать: она была исправлено слишком поздно для включения в Perl 5.22. Ведётся
работа по исправлению множества по-прежнему сломанных CPAN модулей, которая
появится на CPAN, как только она будет завершена. Поэтому вам не придётся ждать
Perl 5.24, чтобы получить работающие версии.

=back

=head2 Платформы, для которых прекращена поддержка

=over 4

=item NeXTSTEP/OPENSTEP

NeXTSTEP была проприетарной платформой, которая поставлялась с рабочими
станциями NeXT в ранние 90-е; OPENSTEP была спецификацией API, которая
предоставляла NeXTSTEP-подобное окружение для не-NeXTSTEP систем. Обе уже долгое
время мертвы, поэтому поддержка сборки Perl на них была удалена.

=back

=head2 Платформо-специфичные заметки

=over 4

=item EBCDIC

Требуется специальная обработка для perl интерпретатора на EBCDIC платформах,
чтобы C<qr/[i-j]/> совпадало только с C<"i"> и C<"j">, поскольку существует 7
символов между кодовыми точками C<"i"> и C<"j">. Эта специальная обработка
срабатывала только для диапазона, обе границы которого являлись литералами.
Теперь это также срабатывает для любых форм C<\N{...}>, указывающих символ по
имени кодовой точки Юникод вместо литерала. Смотрите 
L<perlrecharclass/Character Ranges>.

=item HP-UX

archname теперь отличает use64bitint от use64bitall.

=item Android

Поддержка сборки была улучшена для кросс-компиляции в целом и в частности для
Android.

=item VMS

=over 4

=item *

При создании субпроцесса без ожидания возвращаемое значение теперь корректное
значение PID.

=item *

Исправлен прототип, поэтому линковка не ломается при использовании компилятора
C++ VMS.

=item *

Определение C<finite>, C<finitel> и C<isfinite> было добавлено в
C<configure.com>, поддержка окружения имеет небольшие изменения и исправления
для проверки статуса устаревших возможностей.

=back

=item Win32

=over 4

=item *

F<miniperl.exe> теперь собирается с C<-fno-strict-aliasing>, позволяя 64-битным
сборкам завершаться на GCC 4.8.
L<[perl #123976]|https://rt.perl.org/Ticket/Display.html?id=123976>

=item *

C<nmake minitest> теперь работает на Win32. Из-за проблем с зависимостями вам
необходимо сначала выполнить C<nmake test-prep> и некоторое небольшое число
тестов упадёт.
L<[perl #123394]|https://rt.perl.org/Ticket/Display.html?id=123394>

=item *

Perl теперь может быть собран с C++ режиме на Windows установкой макроса
мэйкфайла C<USE_CPLUSPLUS> в значение "define".

=item *

Списочная форма открытия канала была реализована для Win32. Обратите внимание:
вместо C<system LIST> это больше не откатывается на шелл.
L<[perl #121159]|https://rt.perl.org/Ticket/Display.html?id=121159>

=item *

Новые опции конфигурации C<DebugSymbols> и C<DebugFull> были добавлены к
мейкфайлам Windows.

=item *

Ранее сборка XS модулей (включая модули со CPAN) с использованием Visual C++ для
Win64 приводило к большому числу предупреждений на каждый фал из F<hv_func.h>.
Эти предупреждения были заглушены.

=item *

Поддержка сборки без PerlIO была удалена из мэйкфайлов Windows. Не-PerlIO сборки
считаются устаревшими, начиная с Perl 5.18.0 и уже не поддерживаются в
F<Configure> на POSIX системах.

=item *

От 2 до 6 миллисекунд и семь I/O вызовов было сохранено на каждую попытку
открыть perl модуль для каждого путя в C<@INC>.

=item *

Сборка с Intel C теперь всегда проходит с установленной опцией C99.

=item *

C<%I64d> теперь используется вместо C<%lld> для MinGW.

=item *

Был исправлен крах в C<open> в экспериментальном слое C<:win32>. Также открытие
F</dev/null> (которое работало по умолчанию в C<:unix> слое в Перле Win32) было
реализовано для C<:win32>.
L<[perl #122224]|https://rt.perl.org/Ticket/Display.html?id=122224>

=item *

Была добавлена новая опция мэйкфайла C<USE_LONG_DOUBLE> в dmake мэйкфайле
Windows только для сборки в gcc. Установите её в значение "define", если вы
хотите, чтобы perl использовал long double для большей точности и расширенного
диапазона чисел с плавающей запятой.

=back

=item OpenBSD

На OpenBSD, Perl по умолчанию используется системный C<malloc>, чтобы
задействовать возможности безопасности, которые он предоставляет. Собственная
обёртка malloc использовалась, начиная с v5.14 по соображениям
производительности, но OpenBSD проект верит, что безопасность стоит того и
считает, чтобы пользователи, которым нужна скорость специально потребуют
этого.
L<[perl #122000]|https://rt.perl.org/Ticket/Display.html?id=122000>.

=item Solaris

=over 4

=item *

Мы ищем компилятор Sun Studio в двух местах: F</opt/solstudio*> и
F</opt/solarisstudio*>.

=item *

Сборки на Solaris 10 с опцией C<-Dusedtrace> сразу упадут, так как make
проигнорирует предполагаемую зависимость для сборки C<perldtrace.h>. Добавлена
явная зависимость в C<depend>.
L<[perl #120120]|https://rt.perl.org/Ticket/Display.html?id=120120>

=item *

Опции C99 были удалены; поиск как C<solstudio>, так и C<SUNWspro>; а также
была добавлена поддержка нативного C<setenv>.

=back

=back

=head1 Внутренние изменения

=over 4

=item *

Была добавлена экспериментальная поддержка разрешить операциям в дереве опреаций
на ходить своих родителей, если они есть. Это включается с помощью опции сборки
C<-DPERL_OP_PARENT>. Рассматривается возможность, что когда-нибудь это станет
опцией, включённой по умолчанию, таким образом XS код, который напрямую
запрашивает поле C<op_sibling> должен быть обновлён, чтобы работать нормально в
будущем.

На сборках с C<PERL_OP_PARENT> поле C<op_sibling> было переименовано в
C<op_sibparent> и был добавлен новый флаг C<op_moresib>. На последней операции в
цепи потомков C<op_moresib> является ложью, а C<op_sibparent> указывает на
родителя (если есть), а не равен C<NULL>.

Чтобы существующий код прозрачно работал с использованием C<PERL_OP_PARENT> или
без, было добавлено несколько новых макросов и функций, которые должны
использоваться, вместо того, чтобы напрямую манипулировать с C<op_sibling>.

Для случая, когда требуется прочесть C<op_sibling>, только чтобы определить
следующего потомка, были добавлены два макроса. Для простого сканирования через
цепь потомков:

    for (; kid->op_sibling; kid = kid->op_sibling) { ... }

теперь должно быть написано так:

    for (; OpHAS_SIBLING(kid); kid = OpSIBLING(kid)) { ... }

Для дополнения дерева операций была добавлена общая функция
C<op_sibling_splice()>, которая позволяет манипулировать с цепью
операций-потомков. По аналогии с Perl функцией C<splice()> она позволяет удалить
одну или больше операций из цепи потомков и заменить их нулём или несколькими
новыми операциями. Она прозрачно поддерживает все изменения в потомков,
родителей и op_last указателей и прочего.

Если требуется манипулировать с операциями на низком уровне, то есть три новых
макроса C<OpMORESIB_set>, C<OpLASTSIB_set> и C<OpMAYBESIB_set> , которые
предназначены для низкоуровневой переносимой установки C<op_sibling> /
C<op_sibparent>, а также обновления C<op_moresib>. Первый устанавливает
указатель потомка на нового потомка, второй устанавливает операцию последним
потомком, а третий по условию выполняет первое или второе действие. Обратите
внимание, что в отличии от C<op_sibling_splice()> эти макросы не поддерживают
согласованное состояние родителя в то же самое время (то есть обновление
C<op_first> и C<op_last>, когда это необходимо).

Были добавлены функция C-уровня C<Perl_op_parent()> и метод Perl-уровня
C<B::OP::parent()>. C-функция существует только в сборках с C<PERL_OP_PARENT>
(её использование на ванильных сборках это ошибка во время компиляции).
C<B::OP::parent()> присутствует всегда, но на ванильных сборках он всегда
возвращает C<NULL>. При наличии C<PERL_OP_PARENT> они вернут родителя текущей
операции, если она есть. Переменная C<$B::OP::does_parent> позволяет вам
определить поддерживает ли C<B> получение предка операции.

C<PERL_OP_PARENT> была добавлена в 5.21.2, но интерфейс изменился значительно в
5.21.11. Если вы обновили ваш код до изменений в 5.21.11, потребуется дальнейшая
переработка. Основные изменения после 5.21.2:

=over 4

=item *

Макросы C<OP_SIBLING> и C<OP_HAS_SIBLING> были переименованы в C<OpSIBLING> и
C<OpHAS_SIBLING> для согласованности с другими макросам манипулирующими с
операциями.

=item *

Поле C<op_lastsib> было переименовано в C<op_moresib> и его значение было
инвертировано.

=item *

Макрос C<OpSIBLING_set> был удалён и был заменён на C<OpMORESIB_set>.

=item *

Функция C<op_sibling_splice()> теперь поддерживает нулевой аргумент C<parent>,
при котором срез не затрагивает первую и последнюю операции в цепи потомков.

=back

=item *

Был создан макрос, чтобы позволить XS коду лучше манипулировать с POSIX
категорией локали C<LC_NUMERIC>.
Смотрите L<perlapi/Locale-related functions and macros>.

=item *

Функция полной замены C<atoi> C<grok_atou> теперь замещена C<grok_atoUV>.
Смотрите подробности в L<perlclib>.

=item *

Была добавлена новая функция C<Perl_sv_get_backrefs()>, которая позволяет
получать слабые ссылки, если они доступны, которые указывают на SV.

=item *

Функция C<screaminstr()> была удалена. Несмотря на то, что она отмечена как
публичная, она не была задокументирована и не использовалась в модулях на CPAN.
Вызов функции вызывал фатальную ошибку, начиная с 5.17.0.

=item *

Функции C<newDEFSVOP()>, C<block_start()>, C<block_end()> и C<intro_my()> были
добавлены в API.

=item *

Внутренняя функция C<convert> в F<op.c> была переименована в C<op_convert_list>
и добавлена в API.

=item *

Функция C<sv_magic()> больше не запрещает "ext" магию на доступных только для
чтения значениях. В конце концов perl не может узнать будет ли заданная магия
модифицировать SV или нет.
L<[perl #123103]|https://rt.perl.org/Ticket/Display.html?id=123103>.

=item *

Доступ к L<perlapi/CvPADLIST> в XSUB теперь запрещён.

Поле C<CvPADLIST> было задействовано для других внутренних целей для XSUB.
Поэтому, в частности, вы больше не можете рассчитывать, что он имеет значение
NULL, для проверки является ли CV XSUB. Используйте вместо этого C<CvISXSUB()>.

=item *

SV типа C<SVt_NV> теперь иногда не имеют тела, если конфигурация и платформа
поддерживают это: особенно, когда C<< sizeof(NV) <= sizeof(IV) >>.
"Безтелесность" означает, то NV значение сохраняется непосредственно в заголовке
SV без необходимости выделения отдельного тела. Этот трюк уже использовался для
IV, начиная с 5.9.2 (хотя в случае IV, это использовалось всегда, независимо от
платформы и сборочной конфигурации).

=item *

Переменные C<$DB::single>, C<$DB::signal> и C<$DB::trace> теперь для set- и
get-магии хранят свои значения как IV, и эти IV используются, когда тестируются
их значения в C<pp_dbstate()>. Это предотвращает бесконечную рекурсию в perl,
если перегруженный объект присваивается к любой из этих переменных.
L<[perl #122445]|https://rt.perl.org/Ticket/Display.html?id=122445>.

=item *

C<Perl_tmps_grow()>, который был отмечен, как публичное API, но не
документирован, был удалён из публичного API. Это изменение не затрагивает
XS-код, который использует макрос C<EXTEND_MORTAL> для предрасширения mortal
стека.

=item *

Внутренности Perl больше не устанавливают и не используют флаг C<SVs_PADMY>.
C<SvPADMY()> теперь возвращает истинное значение для всего, что не отмечено
C<PADTMP>, а C<SVs_PADMY> теперь определено как 0.

=item *

Макросы C<SETsv> и C<SETsvUN> были удалены. Они больше не используется в
базовом Perl, начиная с коммита 6f1401dc2a пять лет назад, и не были обнаружены
на CPAN.

=item *

Бит C<< SvFAKE >> (неиспользуемый на HV) неофициально зарезервирован Дэвидом
Митчеллом для будущей работы над vtables.

=item *

Функция C<sv_catpvn_flags()> принимает флаги C<SV_CATBYTES> и C<SV_CATUTF8>,
которые указывают, что добавляемая строка является байтами или UTF-8
соответственно. (Эти флаги присутствуют начиная с 5.16.0, но раньше не
упоминались как часть API.)

=item *

Был представлен новый класс опкодов C<< METHOP >>. Он хранит информацию,
используемую во время исполнения для улучшения производительности вызовов
методов класса/объекта.

C<< OP_METHOD >> и C<< OP_METHOD_NAMED >> были изменены из C<< UNOP/SVOP >> в
C<< METHOP >>.

=item *

C<cv_name()> это новая функция API, которой может быть передан CV или GV. Она
возвращает SV, содержащий имя подпрограммы, для использования в диагностике.

L<[perl #116735]|https://rt.perl.org/Ticket/Display.html?id=116735>
L<[perl #120441]|https://rt.perl.org/Ticket/Display.html?id=120441>

=item *

C<cv_set_call_checker_flags()> это новая функция API, которая работает как
C<cv_set_call_checker()>, но в отличии от неё позволяет вызывающему указать
требует ли проверщик вызова полного GV для вывода имени подпрограммы, или вместо
него может быть передан CV. Какое бы значение не было передано оно будет
приемлемо для C<cv_name()>. C<cv_set_call_checker()> гарантирует, что это будет
GV, но ему может потребоваться создать его на лету, что неэффективно.
L<[perl #116735]|https://rt.perl.org/Ticket/Display.html?id=116735>

=item *

C<CvGV> (который не является частью API) теперь более сложный макрос, который
может функции и создавать GV. Для тех случаев, когда он используется как
логическое значение, добавляется C<CvHASGV>, который вернёт истину для CV,
которое номинально имеет GV, но без создания самого GV. C<CvGV> также
теперь возвращает GV для лексических подпрограмм.
L<[perl #120441]|https://rt.perl.org/Ticket/Display.html?id=120441>

=item *

Функция L<perlapi/sync_locale> была добавлена в публичное API. Нужно избегать
изменений локали программы из XS кода. Однако это требуется некоторым не-Перл
библиотекам, вызываемым из XS, как например C<Gtk>. Когда это происходит, Перлу
необходимо сообщить о том, что локаль была изменена. Используйте эту функцию,
чтобы сделать это, до того как вернуть управление Перл.

=item *

Определения и метки для флагов в поле C<op_private> операций теперь
автогенерируются из данных в F<regen/op_private>. Эффект от этого можно
заметить в том, что вывод некоторых флагов C<Concise> может немного отличаться
а вывод флагов S<C<perl -Dx>> может отличаться значительно (они оба используют
сейчас тот же набор меток). Также, сборки с отладочной информацией теперь имеют
несколько новых assert'ов в C<op_free()>, чтобы быть уверенным, что операции не
имеют неопознанных флагов, установленных в C<op_private>.

=item *

Устаревшая переменная C<PL_sv_objcount> была удалена.

=item *

Perl теперь пытается сохранить категорию локали C<LC_NUMERIC> установленной в
"C" за исключением операций, которым требуется установить её для заданной
локали программы. Это защищает множество XS модулей, которые не могут
справиться с ситуацией, когда разделитель целой и дробной части не является
точкой. До этого релиза Perl устанавливал эту категорию в "C", но вызов
C<POSIX::setlocale()> менял её. Теперь подобный вызов изменит локаль категории
C<LC_NUMERIC> для программы, но локаль сообщаемая XS коду останется в значении
"C". Есть новые макросы для манипуляции с локалью LC_NUMERIC, включая 
C<STORE_LC_NUMERIC_SET_TO_NEEDED> и
C<STORE_LC_NUMERIC_FORCE_TO_UNDERLYING>.
Смотрите L<perlapi/Locale-related functions and macros>.

=item *

Был написан новый макрос L<C<isUTF8_CHAR>|perlapi/isUTF8_CHAR>, который
эффективно определяет является ли строка, переданная параметром, начинается с
правильно сформированным кодированным в UTF-8 символом.

=item *

В следующих функциях приватного API удалён параметр контекста:
C<Perl_cast_ulong>,  C<Perl_cast_i32>, C<Perl_cast_iv>,    C<Perl_cast_uv>,
C<Perl_cv_const_sv>, C<Perl_mg_find>,  C<Perl_mg_findext>, C<Perl_mg_magical>,
C<Perl_mini_mktime>, C<Perl_my_dirfd>, C<Perl_sv_backoff>, C<Perl_utf8_hop>.

Обратите внимание, что версии этих функций без префикса, которые являются
частью публичного API, такие как C<cast_i32()>, остались неизменными.

=item *

Типы C<PADNAME> и C<PADNAMELIST> теперь раздельные типы и больше не могут быть
просто приравнены к SV и AV.
L<[perl #123223]|https://rt.perl.org/Ticket/Display.html?id=123223>.

=item *

Имена pad теперь всегда в UTF-8. Макрос C<PadnameUTF8> всегда возвращает
истину. Ранее это уже было так, но поддержка для двух различных типов
внутреннего представления имён pad была удалена.

=item *

Был добавлен новый класс операций C<UNOP_AUX>. Это субкласс C<UNOP> с
добавлением поля C<op_aux>, который указывает на массив объединений UV, SV* и
т.д. Он предназначен для случая, когда операции требуется сохранить больше
данных, чем просто C<op_sv> или подобное. На данный момент единственная
подобная операция этого типа это C<OP_MULTIDEREF> (смотрите следующий пункт).

=item *

Была добавлена новая операция C<OP_MULTIDEREF>, которая производит один или
несколько поисков во вложенных массивах или хешах, где ключ является константой
иди простой переменной. Например, выражение C<$a[0]{$k}[$i]>, которая ранее
включало десять операций C<rv2Xv>, C<Xelem>, C<gvsv> и C<const>, теперь
выполняется за одну операцию C<multideref>. Это также работает для C<local>,
C<exists> и C<delete>. Сложные выражения для индекса, такие как C<[$i+1]>
по-прежнему выполняются с использованием C<aelem>/C<helem>, а просмотр
одноуровнего массива с небольшим индексом-константой по-прежнему выполняется с
использованием C<aelemfast>.

=back

=head1 Избранные исправления ошибок

=over 4

=item *

C<close> теперь устанавливает C<$!>

Когда происходит ошибка ввода/вывода, факт подобной ошибки сохранялся в
дескриптор. C<close> возвращает ложь для подобных дескрипторов. Ранее значение
C<$!> оставлялось C<close> нетронутым, поэтому общепринятый подход записи
S<C<close $fh or die $!>> не работал полноценно. Теперь дескриптор сохраняет
также и значение C<$!>, а C<close> его восстанавливает.

=item *

C<no re> теперь делает больше и лексически
 
Раньше использование C<no re> отключало лишь несколько опций. Теперь оно
полностью отключает все включённые опции. Например, раньше вы не могли
отключить отладку после её включения в том же самом блоке.

=item *

C<pack("D", $x)> и C<pack("F", $x)> теперь обнуляют заполнение на x86 сборках с
long double. При некоторых сборочных опциях на GCC 4.8 и старше они
перезаписывали обнулённое заполнение или целиком игнорировали
инициализированный буфер. Это приводило к ошибкам в F<op/pack.t>
L<[perl #123971]|https://rt.perl.org/Ticket/Display.html?id=123971>

=item *

Расширение массива, клонированного из потока родителя могло привести к ошибке
"Предпринята попытка модификации значения доступного только на чтение", при
попытке модифицировать новые элементы.
L<[perl #124127]|https://rt.perl.org/Ticket/Display.html?id=124127>

=item *

Ошибка предположения и последующий крах в выражении C<< *x=<y> >> была
исправлена.
L<[perl #123790]|https://rt.perl.org/Ticket/Display.html?id=123790>

=item *

Ошибка возможного краха/зацикливания, связанная с компиляцией лексических
подпрограмм, была исправлена.
L<[perl #124099]|https://rt.perl.org/Ticket/Display.html?id=124099>

=item *

UTF-8 теперь работает корректно в именах функции, в нецитированных
ограничителях встроенных документов, а также в именах переменных, используемых
как индексы массива.
L<[perl #124113]|https://rt.perl.org/Ticket/Display.html?id=124113>

=item *

Повторяемый глобальный шаблон в скалярном контексте на крупных
связанных строках выполнял поиск соответствия с экспоненциальным замедлением, в
зависимости от текущей позиции в строке.
L<[perl #123202]|https://rt.perl.org/Ticket/Display.html?id=123202>

=item *

Были исправлены различные крахи, из-за того, что парсер смущали синтаксические
ошибки.
L<[perl #123801]|https://rt.perl.org/Ticket/Display.html?id=123801>
L<[perl #123802]|https://rt.perl.org/Ticket/Display.html?id=123802>
L<[perl #123955]|https://rt.perl.org/Ticket/Display.html?id=123955>
L<[perl #123995]|https://rt.perl.org/Ticket/Display.html?id=123995>

=item *

Был исправлен C<split> в области лексической C<$_> не падать из-за нарушения
предположения.
L<[perl #123763]|https://rt.perl.org/Ticket/Display.html?id=123763>

=item *

Синтаксис C<my $x : attr> внутри различных списочных операторов больше не
приводит к падению из-за нарушения предположения.
L<[perl #123817]|https://rt.perl.org/Ticket/Display.html?id=123817>

=item *

Знак C<@> в кавычках с последующей не-ASCII цифрой (что не является корректным
идентификатором) приводил парсер к краху вместо того, чтобы просто попытаться
использования C<@> как литерал. Это было исправлено.
L<[perl #123963]|https://rt.perl.org/Ticket/Display.html?id=123963>

=item *

C<*bar::=*foo::=*glob_with_hash> падали, начиная с Perl 5.14, но больше не
делают этого.
L<[perl #123847]|https://rt.perl.org/Ticket/Display.html?id=123847>

=item *

C<foreach> в скалярном контексте не размещал элемент на стеке, приводя к
ошибкам. (S<C<print 4, scalar do { foreach(@x){} } + 1>> напечатает 5.) Это
было исправлено и возвращает C<undef>.
L<[perl #124004]|https://rt.perl.org/Ticket/Display.html?id=124004>

=item *

Было исправлено несколько случаев, когда данные, хранившие значения
переменных окружения в базовом C коде, могли потенциально быть переписаны.
L<[perl #123748]|https://rt.perl.org/Ticket/Display.html?id=123748>

=item *

Некоторые шаблоны, начинающиеся с C</.*..../> при поиске совпадения в длинных
строках были медленными, начиная с v5.8, а некоторые формы C</.*..../i>
замедлились, начиная с v5.18. Теперь они снова быстрые.
L<[perl #123743]|https://rt.perl.org/Ticket/Display.html?id=123743>.

=item *

Оригинальное видимое значение C<$/> сохраняется, когда устанавливается в
некорректное значение. Раньше, например, если вы устанавливали C<$/> в ссылку
на массив, то Perl выводил ошибку исполнения и не устанавливал C<PL_rs>, и код,
который проверял C<$/> видел ссылку на массив.
L<[perl #123218]|https://rt.perl.org/Ticket/Display.html?id=123218>.

=item *

В шаблонах регулярных выражений, POSIX класс, как например C<[:ascii:]>, должен
быть внутри класса символов, заключённый в скобки, как например
C<qr/[[:ascii:]]/>. Теперь выводится предупреждение, когда что-то напоминающее
POSIX класс находится не внутри класса, заключённого в скобки. Это
предупреждение не выводилось, если было отрицание POSIX класса: C<[:^ascii:]>.
Теперь это исправлено.

=item *

В Perl 5.14.0 появился баг, когда S<C<eval { LABEL: }>> приводил к краху. Это
было исправлено.
L<[perl #123652]|https://rt.perl.org/Ticket/Display.html?id=123652>.

=item *

Были исправлены различные крахи, из-за того, что парсер смущали синтаксические
ошибки.
L<[perl #123617]|https://rt.perl.org/Ticket/Display.html?id=123617>.
L<[perl #123737]|https://rt.perl.org/Ticket/Display.html?id=123737>.
L<[perl #123753]|https://rt.perl.org/Ticket/Display.html?id=123753>.
L<[perl #123677]|https://rt.perl.org/Ticket/Display.html?id=123677>.

=item *

Код, как например C</$a[/>, раньше читал следующую строку ввода и рассматривал
её как если бы она шла сразу после открытой скобки. Некоторый некорректный код
мог парситься и выполняться, но некоторый код приводил к краху, поэтому
это теперь запрещено.
L<[perl #123712]|https://rt.perl.org/Ticket/Display.html?id=123712>.

=item *

Исправлено переполнение аргумента для C<pack>.
L<[perl #123874]|https://rt.perl.org/Ticket/Display.html?id=123874>.

=item *

Исправлена обработка не строгого C<\x{}>. Теперь C<\x{}> является эквивалентом
для C<\x{0}> вместо того, чтобы падать.

=item *

C<stat -t> больше не считается стекируемым, также как и C<-t stat>.
L<[perl #123816]|https://rt.perl.org/Ticket/Display.html?id=123816>.

=item *

Следующее выражение больше не приводит к SEGV: C<qr{x+(y(?0))*}>.

=item *

Исправлен бесконечный цикл в разборе обратных ссылок в регулярных выражениях.

=item *

Несколько небольших исправлений ошибок в поведении Infinity и NaN, включая
предупреждения, когда производится приведение к числу строк, содержащих
Infinity и NaN. Например, "NaNcy" больше приводится к NaN.

=item *

Исправлена ошибка в шаблонах регулярных выражений, которая могла привести к
сегфолту и другим крахам. Это происходит только в шаблонах, скомпилированных с
C</i>, принимающих во внимание текущую POSIX локаль (что обычно означает, что
они скомпилированы в области действия C<S<use locale>>), и это должна быть
строка с по крайне мере 128 последовательными совпадающими байтами.
L<[perl #123539]|https://rt.perl.org/Ticket/Display.html?id=123539>.

=item *

C<s///g> теперь работает на очень больших строках (где больше 2 миллиардов
итераций), вместо вылета с сообщением 'Зацикливание замены'.
L<[perl #103260]|https://rt.perl.org/Ticket/Display.html?id=103260>.
L<[perl #123071]|https://rt.perl.org/Ticket/Display.html?id=123071>.

=item *

C<gmtime> больше не падает на значениях NaN.
L<[perl #123495]|https://rt.perl.org/Ticket/Display.html?id=123495>.

=item *

C<\()> (ссылка на пустой список) и C<y///> с лексической C<$_> в текущей
области видимости может выполнять запись и в начало, и в конец стека. Теперь это
исправлено и предварительно расширяет стек.

=item *

C<prototype()> без аргументов раньше читал предыдущий элемент на стеке,
поэтому S<C<print "foo", prototype()>> выводило прототип foo. Это было
исправлено и вместо этого использует C<$_>.

L<[perl #123514]|https://rt.perl.org/Ticket/Display.html?id=123514>.

=item *

Некоторые случаи, когда лексические state подпрограммы объявлены внутри
предекларированных подпрограммах, приводили к краху. Например, при выполнении
eval строки, включающей имя внешней переменной. Теперь такого не происходит.

=item *

Некоторые случаи вложенных лексических подпрограмм внутри анонимных подпрограмм
могли вызывать ошибку 'Bizarre copy' или возможно даже падать.

=item *

При попытке выдать предупреждения, perl отладчик по умолчанию  (F<perl5db.pl>)
иногда возвращал 'Undefined subroutine &DB::db_warn called'. Эта ошибка,
которая стала происходить в  Perl 5.18, теперь была исправлена.
L<[perl #123553]|https://rt.perl.org/Ticket/Display.html?id=123553>.

=item *

Некоторые синтаксические ошибки в заменах, таких как C<< s/${<>{})// >>,
приводили к краху начиная с Perl 5.10. (В некоторых случаях крах не происходил
до версии 5.16). Крах, естественно, был исправлен.
L<[perl #123542]|https://rt.perl.org/Ticket/Display.html?id=123542>.

=item *

Исправлено несколько переполнений при увеличении длины строки, в частности,
выражение повтора, как например, S<C<33 x ~3>>, приводило к крупному
переполнению буфера, так как размер нового буфера вывода неправильно
обрабатывался в C<SvGROW()>. Выражения, наподобие этого теперь корректно
сигнализируют о панике при выделении памяти.
L<[perl #123554]|https://rt.perl.org/Ticket/Display.html?id=123554>.

=item *

C<< formline("@...", "a"); >> приводит к краху.  Случай C<FF_CHECKNL>
в C<pp_formline()> не устанавливает указатель, который отмечал позицию среза,
что приводило к тому, что случай C<FF_MORE> приводил к краху в нарушением
сегментации. Это было исправлено.
L<[perl #123538]|https://rt.perl.org/Ticket/Display.html?id=123538>.

=item *

Было исправлено возможное переполнение буфера и крах при разборе литерального
шаблона при компиляции регулярного выражения.
L<[perl #123604]|https://rt.perl.org/Ticket/Display.html?id=123604>.

=item *

C<fchmod()> и C<futimes()> теперь устанавливают C<$!>, когда у них происходит
ошибка, при передаче закрытого файлового дескриптора.
L<[perl #122703]|https://rt.perl.org/Ticket/Display.html?id=122703>.

=item *

C<op_free()> и C<scalarvoid()> больше не падают из-за переполнения стека при
освобождении глубокого рекурсивного дерева операций.
L<[perl #108276]|https://rt.perl.org/Ticket/Display.html?id=108276>.

=item *

В Perl 5.20.0, в C<$^N> стал отключаться UTF-8 флаг, если к нему получали
доступ из кодового блока внутри регулярного выражения, кодируя значение в
UTF-8. Это было исправлено.
L<[perl #123135]|https://rt.perl.org/Ticket/Display.html?id=123135>.

=item *

Завершившийся ошибкой вызов C<semctl> больше не переписывает существующие
элементы на стеке, что означает, что C<(semctl(-1,0,0,0))[0]> больше не выдаёт
предупреждение о "неициализированности".

=item *

C<else{foo()}> без пробела перед C<foo> теперь устанавливает правильный номер
строки для этого выражения.
L<[perl #122695]|https://rt.perl.org/Ticket/Display.html?id=122695>.

=item *

Иногда присвоение в C<@array = split> оптимизируется так, что C<split> пишет
непосредственно в массив. Это приводило к ошибкам, нарушавшим возможность
использовать это выражение для lvalue контекста. Поэтому
C<(@a=split//,"foo")=bar()> приводило к ошибке. (Эта ошибка появилась вероятно
в Perl 3, Когда эта оптимизация была добавлена). Теперь это было исправлено.
L<[perl #123057]|https://rt.perl.org/Ticket/Display.html?id=123057>.

=item *

Когда список аргументов проваливает проверку, заданную сигнатурой функции
(которая по-прежнему экспериментальная возможность), результирующее сообщение
об ошибке теперь даёт имя файла и номер строки вызывающей стороны, а не
вызванной подпрограммы.
L<[perl #121374]|https://rt.perl.org/Ticket/Display.html?id=121374>.

=item *

Флип-флоп операторы (C<..> и C<...> в скалярном контексте) раньше поддерживали
отдельное состояние для каждого рекурсивного уровня (число раз, когда внешняя
подпрограмма вызывалась рекурсивно), вопреки документации. Теперь каждое
замыкание имеет внутреннее состояния для каждого флип-флопа.
L<[perl #122829]|https://rt.perl.org/Ticket/Display.html?id=122829>.

=item *

Флип-флоп оператор (C<..> в скалярном контексте) возвращал один и тот же скаляр
каждый раз, пока окружающая подпрограмма вызывалась рекурсивно. Теперь он
всегда возвращает новый скаляр.
L<[perl #122829]|https://rt.perl.org/Ticket/Display.html?id=122829>.

=item *

C<use>, C<no>, метки оператора, специальные блоки (C<BEGIN>) и pod теперь
всегда разрешены, как первая часть в C<map> или C<grep> блоках, блоках после
C<print> или C<say> (или других функций) возвращающих хендл, и внутри
C<${...}>, C<@{...}> и подобных. 
L<[perl #122782]|https://rt.perl.org/Ticket/Display.html?id=122782>.

=item *

Оператор повтора C<x> теперь распространяет lvalue контекст на свои аргументы с
левой стороны, когда используется в контекстах, наподобие C<foreach>. Это
позволяет S<C<for(($#that_array)x2) { ... }>> ожидаемо работать, если цикл
модифицирует C<$_>.

=item *

C<(...) x ...> в скалярном контексте раньше портило стек, если на один из
операндов действовала перегрузка "x", вызывая ошибочное поведение.
L<[perl #121827]|https://rt.perl.org/Ticket/Display.html?id=121827>.

=item *

Присвоение к лексическому скаляру часто оптимизируется; например, в C<my $x; $x
= $y + $z> оператор присвоения удаляется и оператор сложения пишет
непосредственно в C<$x>. Различные ошибки, связанные с этой оптимизацией были
исправлены. Некоторые операторы на правой стороне иногда вообще не могут
выполнить присвоение или присваивают неверное значение, или вызывают STORE
дважды или вообще не разу на связанных переменных. Затронутыми операторами были
C<$foo++>, C<$foo--> и C<-$foo> при действии C<use integer>, C<chomp>, C<chr>
and C<setpgrp>.

=item *

Списочные присвоения иногда приводили к ошибкам, если тот же скаляр оказывался
на обоих сторонах присвоения из-за использования C<tied>, C<values> или
C<each>. Результатом становилось присвоение ошибочного значения.

=item *

C<setpgrp($nonzero)> (с одним аргументом) по ошибке был изменён в 5.16
и стал значить C<setpgrp(0)>. Это было исправлено.

=item *

C<__SUB__> возвращало ошибочное значение или портило память при работе
в отладчике (опция C<-d>) и в подпрограммах, содержащих C<eval $string>.

=item *

Когда S<C<sub () { $var }>> становилась встраиваемой, то она теперь возвращает
каждый раз разный скаляр, также как и невстраиваемая, хотя Perl по-прежнему
оптимизирует копию в случаях, если это не имеет никакой заметной разницы.

=item *

S<C<my sub f () { $var }>> и S<C<sub () : attr { $var }>> больше не подлежат
встраиванию. Первый приведёт к краху; последний просто выкинет атрибут.
Исключение делается лишь для малоизвестного атрибута C<:method>, который не
делает ничего особенного.

=item *

Встраивание подпрограмм с пустым прототипом теперь более последовательное, чем
раньше. Раньше подпрограмма с множеством операторов, из которых все кроме
последнего оптимизировались, могла встраиваться, только если это была анонимная
подпрограмма, содержащая строковый C<eval>, или объявление C<state>, или
замыкание внешней лексической переменной (или любой анонимной подпрограммой при
работе отладчика). Теперь любая подпрограмма, которая приводится к простой
константе после оптимизации операторов подлежит встраиванию. Это применяется
для вещей наподобие C<sub () { jabber() if DEBUG; 42 }>.

Некоторые подпрограммы с явным C<return> делались встраиваемыми, вопреки
документации. Теперь C<return> всегда предотвращает встраивание.

=item *

На некоторых системах, таких как VMS, C<crypt> может вернуть не-ASCII строку.
Если скаляр, которому идёт присвоение, содержал до этого UTF-8 строку, то
C<crypt> не будет убирать UTF-8 флаг, таким образом искажая возвращаемое
значение. Это происходило с S<C<$lexical = crypt ...>>.

=item *

C<crypt> больше не вызывает C<FETCH> дважды на связанном первом аргументе.

=item *

Незавершённый встроенный документ на последней строке оператора цитирования 
(C<qq[${ <<END }]>, C</(?{ <<END })/>) больше не приводит к двойному
освобождению памяти. Этот дефект появился в 5.18.

=item *

C<index()> и C<rindex()> больше не приводят к краху, когда используются на
строках размером больше, чем 2 Гбайта.
L<[perl #121562]|https://rt.perl.org/Ticket/Display.html?id=121562>.

=item *

Небольшая умышленная утечка памяти в C<PERL_SYS_INIT>/C<PERL_SYS_INIT3> на
сборках Win32 была исправлена. Это может затронуть встраиваемые сборки, которые
регулярно создают и разрушают движок perl внутри одного процесса.

=item *

C<POSIX::localeconv()> теперь возвращает данные для текущей локали программы
даже если вызывается вне области действия S<C<use locale>>.

=item *

C<POSIX::localeconv()> теперь корректно работает на платформах, которые не
имеют C<LC_NUMERIC> и/или C<LC_MONETARY>, или на которых Perl был скомпилирован
игнорировать обе или какую-либо одну из этих категорий локали. В подобных
случаях в хеше, возвращаемом C<localeconv()> нет полей для соответствующих
значений.

=item *

C<POSIX::localeconv()> теперь маркирует соответственно возвращаемые значения
как UTF-8 или нет. Ранее они всегда возвращались как байты, даже если должны
были кодироваться как UTF-8.

=item *

На Microsoft Windows внутри области видимости C<S<use locale>> следующие POSIX
классы символов возвращают результаты для множества локалей, которые не
соответствуют POSIX стандарту:
C<[[:alnum:]]>,
C<[[:alpha:]]>,
C<[[:blank:]]>,
C<[[:digit:]]>,
C<[[:graph:]]>,
C<[[:lower:]]>,
C<[[:print:]]>,
C<[[:punct:]]>,
C<[[:upper:]]>,
C<[[:word:]]>,
и
C<[[:xdigit:]]>.
Так происходило из-за того, что сама реализация Microsoft не следовала
стандарту. Perl теперь принимает специальные меры, чтобы скорректировать это.

=item *

Множество проблем было обнаружено и исправлено сканером
L<Coverity|http://www.coverity.com/>.

=item *

C<system()> и друзья должны теперь работать правильно на Android сборках.

По недосмотру, значение, указанное в C<-Dtargetsh> для F<Configure>,
игнорировалось в части сборочного процесса. В итоге кросскомпилируемый perl для
Android оказывался с дефектной версией C<system()>, C<exec()> и обратных
кавычек: команды искали C</bin/sh>, вместо C</system/bin/sh>, что приводило к
ошибке для большинства устройств, устанавливая C<$!> в значение C<ENOENT>.

=item *

C<qr(...\(...\)...)>,
C<qr[...\[...\]...]>,
и
C<qr{...\{...\}...}>
теперь работают. Ранее было невозможно экранировать эти три левых символа с
обратной косой чертой внутри шаблона регулярного выражения, где иначе они
рассматривались как метасимволы, открывающий шаблон разделитель являлся тем
символом, а закрывающий разделитель являлся его зеркальным отображением.

=item *

C<< s///e >> на заражённых UTF-8 строках портили C<< pos() >>. Эта ошибка
появилась в 5.20 и теперь исправлена.
L<[perl #122148]|https://rt.perl.org/Ticket/Display.html?id=122148>.

=item *

Не-граница слова в регулярных выражениях (C<< \B >>) не всегда совпадала с
концом строки; в частности,  C<< q{} =~ /\B/ >> не совпадало. Эта ошибка
появилась в 5.14 и теперь исправлена.
L<[perl #122090]|https://rt.perl.org/Ticket/Display.html?id=122090>.

=item *

C<< " P" =~ /(?=.*P)P/ >> должно совпадать, но не совпадало. Теперь это
исправлено.
L<[perl #122171]|https://rt.perl.org/Ticket/Display.html?id=122171>.

=item *

Ошибка компиляции C<use Foo> в C<eval> могло привести к ложному определению
подпрограммы C<BEGIN>, которое выводило предупреждение "Subroutine BEGIN
redefined" на следующее использование C<use> или другого блока C<BEGIN>.
L<[perl #122107]|https://rt.perl.org/Ticket/Display.html?id=122107>.

=item *

Синтаксис C<method { BLOCK } ARGS> теперь корректно разбирает аргументы, если
они начинаются с открывающей скобки.
L<[perl #46947]|https://rt.perl.org/Ticket/Display.html?id=46947>.

=item *

Внешние библиотеки и Perl могут по разному воспринимать, что такое локаль. Это
становится проблемой, при разборе строки версии, если разделитель цифр локали
изменился. Разбор версии был исправлен, чтобы убедиться, что он обрабатывает
локаль корректно.
L<[perl #121930]|https://rt.perl.org/Ticket/Display.html?id=121930>.

=item *

Была исправлена ошибка, когда ошибка предположения на нулевую длину и кодовый
блок внутри регулярного выражения, приводили к тому, что C<pos> видел
некорректное значение.
L<[perl #122460]|https://rt.perl.org/Ticket/Display.html?id=122460>.

=item *

Разыменование константы теперь работает корректно для тайпглоб констант. Ранее
глоб приводился к строковой форме и извлекалось его имя. Теперь используется
сам глоб.
L<[perl #69456]|https://rt.perl.org/Ticket/Display.html?id=69456>

=item *

При разборе сигила (C<$> C<@> C<%> C<&>) с последующей фигурной скобкой, парсер
больше не пытается угадать является ли это блоком или конструктором хеша
(вызывая позже синтаксическую ошибку при таком предположении), так как дальше
может идти только блок.

=item *

S<C<undef $reference>> теперь освобождает ссылку немедленно, вместо того, чтобы
ждать следующего выражения.
L<[perl #122556]|https://rt.perl.org/Ticket/Display.html?id=122556>

=item *

Различные случаи, когда имя подпрограммы используется (автозагрузка,
перегрузка, сообщения об ошибках), раньше приводило к краху для лексической
подпрограммы. Теперь это было исправлено.

=item *

Поиск bareword теперь пытается избежать создания пакетов, если окажется, что
bareword это не имя подпрограммы.

=item *

Компиляция анонимных констант (например, C<sub () { 3 }>) теперь не удаляет
подпрограмму с именем C<__ANON__> в текущем пакете. Удалялось не только
C<*__ANON__{CODE}>, но также возникала утечка памяти. Этот баг появился в Perl
5.8.0.

=item *

Объявление заглушки, наподобие C<sub f;> и C<sub f ();> больше не удаляло
константу с тем же именем, определённую с помощью C<use constant>. Этот баг
появился в Perl 5.10.0.

=item *

C<qr/[\N{named sequence}]/> теперь работает правильно в большинстве случаев.

Некоторые имена, известные в C<\N{...}> ссылаются на последовательность из
нескольких символов, вместо обычного единственного символа. Классы символов,
заключённые в скобки обычно совпадают с одни символом, но теперь появилась
специальная поддержка, которая позволяет им совпадать с именованной
последовательностью, но не в случае, если класс инвертирован или
последовательность указана в начале или конце диапазона. В этих случаях
изменение поведения от изначального это несколько переработанное сообщение о
фатальной ошибке, выводимое если класс является частью конструкции C<?[...])>.
Когда C<[...]> находится в одиночестве, возникает такое же нефатальное
предупреждение, как и раньше, и используется только первый символ
последовательности, также как и раньше.

=item *

Заражённые константы, которые вычисляются во время компиляции больше не
приводят к тому, что не относящиеся выражения также становились заражёнными.
L<[perl #122669]|https://rt.perl.org/Ticket/Display.html?id=122669>

=item *

S<C<open $$fh, ...>>, который создавал хендл с именем наподобие
C<"main::_GEN_0">, не давал хендлу правильный счётчик ссылок, поэтому могло
происходить двойное освобождение памяти.

=item *

При решении является ли bareword именем метода, парсер мог быть запутан, если
C<our> подпрограмма с тем же именем существует и пытается найти метод в пакете
C<our> подпрограммы, вместо пакета вызывающего.

=item *

Парсер больше не путается при указании C<\U=> внутри строки в двойных кавычках.
Раньше это приводило к синтаксической ошибке, но теперь компилируется
корректно.
L<[perl #80368]|https://rt.perl.org/Ticket/Display.html?id=80368>

=item *

Всегда подразумевалось, что файловые тестовые операторы C<-B> и C<-T>
рассматривали кодированные в UTF-8 файлы как текст.
(L<perlfunc|perlfunc/-X FILEHANDLE> был обновлён, чтобы уточнить это). Раньше,
существовала возможность, что некоторые файлы рассматривались как UTF-8 но на
деле они не были валидным UTF-8. Теперь это исправлено. Операторы теперь
работают и на EBCDIC платформах.

=item *

При некоторых условиях предупреждение возникающее при компиляции шаблона
регулярного выражения выводилось несколько раз. Теперь это было исправлено.

=item *

В Perl 5.20.0 появилась регрессия, при которой кодированный в UTF-8 шаблон
регулярного выражения, который содержал одиночные ASCII буквы в нижнем регистре
не совпадал с такой же буквой в верхнем регистре. Это было исправлено в 5.20.1
и 5.22.0.
L<[perl #122655]|https://rt.perl.org/Ticket/Display.html?id=122655>

=item *

Развёртка константы может подавить предупреждения, если не действуют
лексические предупреждения (C<use warnings> или C<no warnings>) и C<$^W> была
ложью при компиляции, но стала истиной во время исполнения.

=item *

Загрузка таблиц Юникода при поиске совпадения в регулярном выражении вызывала
ошибки предположения в сборках с отладочной информацией, если предыдущий поиск
совпадения был в таком же регулярном выражении.
L<[perl #122747]|https://rt.perl.org/Ticket/Display.html?id=122747>

=item *

Клонирование треда раньше работало некорректно для лексических подпрограмм,
возможно вызывая крах или двойное освобождение при выходе.

=item *

Начиная с Perl 5.14.0, удаление C<$SomePackage::{__ANON__}> и затем присвоение
значения undef анонимной подпрограмме приводило к внутреннему искажению данных,
приводящему к краху L<Devel::Peek> или выводу бессмысленных данных в L<B.pm|B>.
Это было исправлено.

=item *

S<C<(caller $n)[3]>> теперь выдаёт имя лексической подпрограммы, вместо выдачи
значения C<"(unknown)">.

=item *

C<sort subname LIST> теперь поддерживает использование лексических подпрограмм
как подпрограмм сравнения.

=item *

Создание псевдонимов (например, через S<C<*x = *y>>) может смутить списочное
присвоение, где указываются два имени для одной и той же переменной на каждой
стороне, приводя к присвоению некорректных значений.
L<[perl #15667]|https://rt.perl.org/Ticket/Display.html?id=15667>

=item *

Длинные ограничители встроенных документов вызывают ошибки чтения на коротких
строках ввода. Это было исправлено. Сомнительно, что может возникнуть
какой-либо крах. Этот баг относится ко времени, когда только появилсь
встроенные документы в Perl 3.000 двадцать пять лет назад.

=item *

Оптимизация в C<split>, которая рассматривала S<C<split /^/>>, как
S<C<split /^/m>> имела побочный эффект, когда S<C<split /\A/>> также
рассматривался как S<C<split /^/m>>, чего не должно было происходить. Это было
исправлено. (Однако надо заметить, что S<C<split /^x/>> не вёл себя как
S<C<split /^x/m>>, что также рассматривается как баг и будет исправлен в
будущей версии).
L<[perl #122761]|https://rt.perl.org/Ticket/Display.html?id=122761>

=item *

Малоизвестный синтаксис S<C<my Class $var>> (смотрите L<fields> и
L<attributes>) мог быть сбит с толку в области действия C<use utf8> если
C<Class> был константой, чьё значение содержит Latin-1 символы.

=item *

Блокировка и разблокировка значений через L<Hash::Util> или
C<Internals::SvREADONLY> больше не имеет никакого эффекта на значения, которые
были доступны только на чтение с самого начала. Ранее разблокировка таких
значений приводила к краху, зависаниям и другому некорректному поведению.

=item *

Некоторые нетерминированные C<(?(...)...)> конструкции в регулярных выражениях
могут вызывать крах или выдавать неправильные сообщения об ошибках. C</(?(1)/>
является одним из таких примеров.

=item *

S<C<pack "w", $tied>> больше не вызывает FETCH дважды.

=item *

Списочное присвоение как например, S<C<($x, $z) = (1, $y)>> теперь корректно
работает если C<$x> и C<$y> созданные алиасы в C<foreach>.

=item *

Некоторые шаблоны, включающие кодовые блоки с синтаксическими ошибками, как
например S<C</ (?{(^{})/>>, могут зависать или падать с ошибками на сборках с
отладочной информацией. Теперь они выводят ошибки.

=item *

Ошибка предположения, при разборе C<sort> с включённой отладочной информацией,
была исправлена.
L<[perl #122771]|https://rt.perl.org/Ticket/Display.html?id=122771>.

=item *

S<C<*a = *b; @a = split //, $b[1]>> может вызвать некорректное чтение и вывести
мусорный результат.

=item *

В выражении S<C<() = @array = split>>, S<C<() =>> в начале больше не смущает
оптимизатор в предположении, что лимит 1.

=item *

Фатальное предупреждение больше не предотвращает вывод синтаксических ошибок.
L<[perl #122966]|https://rt.perl.org/Ticket/Display.html?id=122966>.

=item *

Исправлена ошибка NaN double в long-double конвертирование на VMS. Для чистых
NaN (и только на Itanium, не Alpha) выводилась отрицательная бесконечность
вместо Nan.

=item *

Исправлена ошибка, которая приводила к тому, что C<< make distclean >>
ошибочно оставлял некоторые файлы.
L<[perl #122820]|https://rt.perl.org/Ticket/Display.html?id=122820>.

=item *

AIX теперь устанавливает длину корректно в C<< getsockopt >>.
L<[perl #120835]|https://rt.perl.org/Ticket/Display.html?id=120835>.
L<[cpan #91183]|https://rt.cpan.org/Ticket/Display.html?id=91183>.
L<[cpan #85570]|https://rt.cpan.org/Ticket/Display.html?id=85570>.

=item *

Фаза оптимизации при компиляции регулярного выражения может работать вечно и
израсходовать всю память при некоторых условиях. Теперь исправлено.
L<[perl #122283]|https://rt.perl.org/Ticket/Display.html?id=122283>.

=item *

Тестовый скрипт F<< t/op/crypt.t >> теперь использует SHA-256 алгоритм, если
алгоритм по умолчанию отключён, вместо ошибки.
L<[perl #121591]|https://rt.perl.org/Ticket/Display.html?id=121591>.

=item *

Исправлена ошибка на единицу при установке размера разделяемого массива.
L<[perl #122950]|https://rt.perl.org/Ticket/Display.html?id=122950>.

=item *

Исправлена ошибка, которая могла привести ко входу perl в бесконечный цикл при
компиляции. В частности, C<while(1)> внутри субсписка, например

    sub foo { () = ($a, my $b, ($c, do { while(1) {} })) }

Этот баг появился в 5.20.0
L<[perl #122995]|https://rt.perl.org/Ticket/Display.html?id=122995>.

=item *

На Win32, если переменная была локализована в псевдопроцессе, который позже
производит fork, восстановление оригинального значения в потомке
псевдо-процесса вызывает порчу памяти и крах в потомке псевдо-процесса (и
соответственно в процессе ОС).
L<[perl #40565]|https://rt.perl.org/Ticket/Display.html?id=40565>.

=item *

Вызов C<write> на формате с полем C<^**> может вызвать панику в C<sv_chop()>,
если не ыбло достаточно аргументов или если переменная, используемая для
заполнения поля была пустой.
L<[perl #123245]|https://rt.perl.org/Ticket/Display.html?id=123245>.

=item *

Не-ASCII лексическая подпрограмма теперь появляется без завершающего мусора,
если она показывается в сообщении об ошибке.

=item *

Прототип подпрограммы  C<\@> больше не выравнивает заключённые в скобки массивы
(взятие ссылки на каждый элемент), но берёт ссылку на сам массив.
L<[perl #47363]|https://rt.perl.org/Ticket/Display.html?id=47363>.

=item *

Блок, не содержащий ничего, вместо цикла C<for> в C-стиле, вызывает повреждение
стека, приводя список вне блока к потере элементов или перезаписи элементов.
Это могло происходить в C<map { for(...){...} } ...> и в списках, содержащих
C<do { for(...){...} }>.
L<[perl #123286]|https://rt.perl.org/Ticket/Display.html?id=123286>.

=item *

C<scalar()> теперь распространяет lvalue контекст, поэтому
S<C<for(scalar($#foo)) { ... }>> может модифицировать C<$#foo> через C<$_>.

=item *

C<qr/@array(?{block})/> больше не умирает с сообщением "Bizarre copy of ARRAY".
L<[perl #123344]|https://rt.perl.org/Ticket/Display.html?id=123344>.

=item *

S<C<eval '$variable'>> во вложенных именованных подпрограммах может иногда
искать глобальную переменную даже при наличии лексической переменной в области
видимости.

=item *

В Perl 5.20.0, C<sort CORE::fake>, где 'fake' это что-угодно кроме ключевого
слова, стало удалять последние 6 символов и рассматривать результаты, как имя
подпрограммы сортировки. Предыдущее поведение, восприятия C<CORE::fake>, как
имени подпрограммы сортировки было восстановлено.
L<[perl #123410]|https://rt.perl.org/Ticket/Display.html?id=123410>.

=item *

Вне C<use utf8> односимвольная Latin-1 лексическая переменная запрещена.
Сообщение об ошибке для этого случая "Can't use global C<$foo>...", выдавало
мусор, вместо имени переменной.

=item *

C<readline> на несуществующем хендле приводил к тому, что C<${^LAST_FH}>
выдавал ссылку на неопределённый скаляр (или падал из-за ошибки предположения).
Теперь C<${^LAST_FH}> неопределён.

=item *

C<(...) x ...> в пустом контексте теперь применяет скалярный контекст к
аргументу с левой стороны, вместо контекста, в котором вызвана текущая
подпрограмма.
L<[perl #123020]|https://rt.perl.org/Ticket/Display.html?id=123020>.

=back

=head1 Известные проблемы

=over 4

=item *

C<pack> значения NaN в perl, скомпилированным в Visual C 6 происходит
неправильно, приводя к ошибкам в тесте F<t/op/infnan.t>.
L<[perl 125203]|https://rt.perl.org/Ticket/Display.html?id=125203>

=item *

Преимущество Perl в способности быть собранным для работы правильно на любой
версии Юникода. Однако в Perl 5.22 самая ранняя такая версия Юникода это 5.1
(текущая версия 7.0).

=item *

Платформы EBCDIC

=over 4

=item *

C<cmp> (и соответственно C<sort>) операторы не всегда дают корректный
результат, когда оба операнда UTF-EBCDIC кодированные строки и есть смесь ASCII
и/или контрольных символов вместе с другими символами.

=item *

Диапазоны, содержащие C<\N{...}> в C<tr///> (и C<y///>) операторах
транслитерации рассматриваются по-разному, чем в эквивалентном диапазоне в
шаблоне регулярного выражения. Они должны, но не вызывают рассмотрение всех
значений в диапазонах ни как Юникод кодовые точки, и ни как нативные.
(L<perlre/Version 8 Regular Expressions> даёт представление о том, как это
должно работать).

=item *

Encode и кодирование в большинстве случаев сломаны.

=item *

Многие CPAN модули, которые поставляются с базовым Perl демонстрируют падающие
тесты.

=item *

C<pack>/C<unpack> с форматом C<"U0"> может не работать правильно.

=back

=item *

Известно, что следующие модули имеют ошибки в тестах с этой версией Perl. Во
многих случаях патчи были отправлены, поэтому надеемся, что вскоре последуют
новые релизы:

=over

=item *

L<B::Generate> версии 1.50

=item *

L<B::Utils> версии 0.25

=item *

L<Coro> версии 6.42

=item *

L<Dancer> версии 1.3130

=item *

L<Data::Alias> версии 1.18

=item *

L<Data::Dump::Streamer> версии 2.38

=item *

L<Data::Util> версии 0.63

=item *

L<Devel::Spy> версии 0.07

=item *

L<invoker> версии 0.34

=item *

L<Lexical::Var> версии 0.009

=item *

L<LWP::ConsoleLogger> версии 0.000018

=item *

L<Mason> версии 2.22

=item *

L<NgxQueue> версии 0.02

=item *

L<Padre> версии 1.00

=item *

L<Parse::Keyword> версии 0.08

=back

=back

=head1 Некролог

Брайн МакКоули умер 8 мая 2015. Он часто писал в Usenet, Perl Monks и другие
Perl форумы, и отправил несколько CPAN дистрибутивов под ником NOBULL, а также
внёс вклад в Perl FAQ. Он участвовал практически в каждой YAPC::Europe и
помогал организовать YAPC::Europe 2006 и QA Хакатон 2009. Его сообразительность
и радость работы с запутанными системами особенно проявлялись в его любви к
настольным играм; многие Perl-монгеры помнят как играли во Fluxx и другие
игры вместе с Брайном. Его будет не хватать.

=head1 Благодарности

Perl 5.22.0 представляет собой примерно 12 месяцев разработки, начиная с Perl
5.20.0 и содержит примерно 590,000 строк изменений в 2,400 файлах от 94
авторов.

Исключая автогенерируемые файлы, документацию и утилиты релиза, было сделано
примерно 370,000 строк изменений в 1,500 .pm, .t, .c и .h файлах.

Perl продолжает бурно развиваться в своей третьей декаде благодаря
активному сообществу пользователей и разработчиков.  Известно, что
следующие люди содействовали в улучшении того, что стало Perl 5.22.0:

Aaron Crane, Abhijit Menon-Sen, Abigail, Alberto Simões, Alex Solovey, Alex
Vandiver, Alexandr Ciornii, Alexandre (Midnite) Jousset, Andreas König,
Andreas Voegele, Andrew Fresh, Andy Dougherty, Anthony Heading, Aristotle
Pagaltzis, brian d foy, Brian Fraser, Chad Granum, Chris 'BinGOs' Williams,
Craig A. Berry, Dagfinn Ilmari Mannsåker, Daniel Dragan, Darin McBride, Dave
Rolsky, David Golden, David Mitchell, David Wheeler, Dmitri Tikhonov, Doug
Bell, E. Choroba, Ed J, Eric Herman, Father Chrysostomos, George Greer, Glenn
D. Golden, Graham Knop, H.Merijn Brand, Herbert Breunung, Hugo van der Sanden,
James E Keenan, James McCoy, James Raspass, Jan Dubois, Jarkko Hietaniemi,
Jasmine Ngan, Jerry D. Hedden, Jim Cromie, John Goodyear, kafka, Karen
Etheridge, Karl Williamson, Kent Fredric, kmx, Lajos Veres, Leon Timmermans,
Lukas Mai, Mathieu Arnold, Matthew Horsfall, Max Maischein, Michael Bunk,
Nicholas Clark, Niels Thykier, Niko Tyni, Norman Koch, Olivier Mengué, Peter
John Acklam, Peter Martini, Petr Písař, Philippe Bruhat (BooK), Pierre
Bogossian, Rafael Garcia-Suarez, Randy Stauner, Reini Urban, Ricardo Signes,
Rob Hoelz, Rostislav Skudnov, Sawyer X, Shirakata Kentaro, Shlomi Fish,
Sisyphus, Slaven Rezic, Smylers, Steffen Müller, Steve Hay, Sullivan Beck,
syber, Tadeusz Sośnierz, Thomas Sibley, Todd Rinaldo, Tony Cook, Vincent Pit,
Vladimir Marek, Yaroslav Kuzmin, Yves Orton, Ævar Arnfjörð Bjarmason.

Список выше конечно неполон, так как был автоматически сгенерирован из истории
системы контроля версий.  В частности, он не включает имена (очень высоко
ценимых) помощников, которые сообщали о проблемах в Perl баг-трекер.

Множество изменений, включённых в этой версии, идут от CPAN модулей, включённых
в ядро Perl.  Мы благодарны всему CPAN сообществу за помощь в развитии Perl.

Полный список всех принимавших участие в разработке в истории Perl смотрите
пожалуйста в файле F<AUTHORS> в дистрибутиве исходного кода Perl.

=head1 Сообщения об ошибках

Если вы найдёте то, что как вы считаете является ошибкой, вы можете проверить
ранее опубликованные статьи в новостной группе comp.lang.perl.misc и базе ошибок
perl на L<http://rt.perl.org/perlbug/>.  Также может быть информация на
L<http://www.perl.org/>, домашней странице Perl.

Если вы уверены, что у вас ещё ни кем не сообщённая ошибка, пожалуйста запустите
программу L<perlbug>, включённую в ваш релиз.  Убедитесь, что вы привели
максимально краткий, но достаточный пример, для воспроизведения проблемы.  Ваш
отчёт по ошибке, вместе с выводом C<perl -V>, будет отправлен на адрес
perlbug@perl.org для анализа командой портирования Perl.

Если ошибка, о котором вы сообщаете, имеет отношение к безопасности, что делает
его неуместным для отправки в публичную архивируемую почтовую рассылку,
пожалуйста отправьте его на perl5-security-report@perl.org.  Это неархивируемая
почтовая рассылка с закрытой подпиской,  которая включает всех главных
коммитеров, и позволит скоординировать выпуск патча для смягчения или
исправления проблемы на всех платформах, на которых поддерживается Perl.
Пожалуйста используйте этот адрес только для проблем безопасности в базовом
Perl, а не для модулей, которые распространяются на CPAN.

=head1 Смотрите также

Файл F<Changes> для просмотра исчерпывающей информации о том, что изменилось.

Файл F<INSTALL> о том, как собирать Perl.

Файл F<README> для общей информации.

Файлы F<Artistic> и F<Copying> для информации по правам.

=cut
